question,answer
"def hash_password(password: str, hasher) -> str:
    """"""
    Hash a password securely.
    
    Args:
        password: Plain text password
        hasher: Password hashing function
    
    Returns:
        Hashed password string
    
    Raises:
        ValueError: If password is too short
    
    # Dependencies: hasher()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""password,hashed"", [
    (""secure_pass123"", ""$2b$12$abcd...""),
    (""another_password"", ""$2b$12$xyz...""),
])
def test_hash_password(password, hashed):
    mock_hasher = Mock(return_value=hashed)
    result = hash_password(password, mock_hasher)
    assert result == hashed
    mock_hasher.assert_called_once_with(password)

def test_hash_password_too_short():
    mock_hasher = Mock()
    with pytest.raises(ValueError):
        hash_password(""123"", mock_hasher)
    with pytest.raises(ValueError):
        hash_password("""", mock_hasher)",,
"def calculate_tax(amount: float, tax_rate: float) -> float:
    """"""
    Calculate tax amount.
    
    Args:
        amount: Base amount for tax calculation
        tax_rate: Tax rate as decimal (e.g., 0.15 for 15%)
    
    Returns:
        Calculated tax amount
    
    Raises:
        ValueError: If amount is negative or tax_rate is invalid
    """"""","import pytest

@pytest.mark.parametrize(""amount,tax_rate,expected"", [
    (100.0, 0.15, 15.0),
    (200.0, 0.10, 20.0),
    (50.0, 0.0, 0.0),
])
def test_calculate_tax(amount, tax_rate, expected):
    assert calculate_tax(amount, tax_rate) == expected

def test_calculate_tax_negative_amount():
    with pytest.raises(ValueError):
        calculate_tax(-100.0, 0.15)

def test_calculate_tax_invalid_rate():
    with pytest.raises(ValueError):
        calculate_tax(100.0, -0.1)
    with pytest.raises(ValueError):
        calculate_tax(100.0, 1.5)",,
"def create_backup(source_path: str, backup_service, notifier) -> str:
    """"""
    Create backup of files and notify completion.
    
    Args:
        source_path: Path to backup
        backup_service: Backup service instance
        notifier: Notification service
    
    Returns:
        Backup ID as string
    
    Raises:
        FileNotFoundError: If source path doesn't exist
        RuntimeError: If backup fails
    
    # Dependencies: backup_service.create(), notifier.send()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""source_path,backup_id"", [
    (""/data/files"", ""backup-001""),
    (""/home/user/docs"", ""backup-002""),
])
def test_create_backup(source_path, backup_id):
    mock_backup = Mock()
    mock_backup.create.return_value = backup_id
    mock_notifier = Mock()
    result = create_backup(source_path, mock_backup, mock_notifier)
    assert result == backup_id
    mock_backup.create.assert_called_once_with(source_path)
    mock_notifier.send.assert_called_once_with(f""Backup {backup_id} completed"")

def test_create_backup_path_not_found():
    mock_backup = Mock()
    mock_backup.create.side_effect = FileNotFoundError(""Path not found"")
    mock_notifier = Mock()
    with pytest.raises(FileNotFoundError):
        create_backup(""/invalid/path"", mock_backup, mock_notifier)

def test_create_backup_failure():
    mock_backup = Mock()
    mock_backup.create.side_effect = RuntimeError(""Backup failed"")
    mock_notifier = Mock()
    with pytest.raises(RuntimeError):
        create_backup(""/data/files"", mock_backup, mock_notifier)",,
"def update_inventory(product_id: int, quantity: int, database, audit_logger) -> bool:
    """"""
    Update product inventory quantity.
    
    Args:
        product_id: Product identifier
        quantity: New quantity value
        database: Database connection
        audit_logger: Logger for audit trail
    
    Returns:
        True if update successful
    
    Raises:
        ValueError: If product_id or quantity is invalid
        RuntimeError: If database update fails
    
    # Dependencies: database.update(), audit_logger.log()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""product_id,quantity"", [
    (1, 100),
    (999, 50),
    (42, 0),
])
def test_update_inventory(product_id, quantity):
    mock_db = Mock()
    mock_db.update.return_value = True
    mock_logger = Mock()
    result = update_inventory(product_id, quantity, mock_db, mock_logger)
    assert result == True
    mock_db.update.assert_called_once_with(product_id, quantity)
    mock_logger.log.assert_called_once()

def test_update_inventory_invalid_inputs():
    mock_db = Mock()
    mock_logger = Mock()
    with pytest.raises(ValueError):
        update_inventory(-1, 100, mock_db, mock_logger)
    with pytest.raises(ValueError):
        update_inventory(1, -10, mock_db, mock_logger)

def test_update_inventory_database_failure():
    mock_db = Mock()
    mock_db.update.side_effect = RuntimeError(""Update failed"")
    mock_logger = Mock()
    with pytest.raises(RuntimeError):
        update_inventory(1, 100, mock_db, mock_logger)",,
"def analyze_sentiment(text: str, analyzer, cache) -> str:
    """"""
    Analyze text sentiment with caching.
    
    Args:
        text: Text to analyze
        analyzer: Sentiment analysis service
        cache: Cache for storing results
    
    Returns:
        Sentiment classification (positive/negative/neutral)
    
    Raises:
        ValueError: If text is empty
        RuntimeError: If analysis fails
    
    # Dependencies: analyzer.analyze(), cache.get(), cache.set()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""text,sentiment"", [
    (""This is great!"", ""positive""),
    (""This is terrible"", ""negative""),
    (""This is okay"", ""neutral""),
])
def test_analyze_sentiment(text, sentiment):
    mock_analyzer = Mock()
    mock_analyzer.analyze.return_value = sentiment
    mock_cache = Mock()
    mock_cache.get.return_value = None
    result = analyze_sentiment(text, mock_analyzer, mock_cache)
    assert result == sentiment
    mock_analyzer.analyze.assert_called_once_with(text)
    mock_cache.set.assert_called_once_with(text, sentiment)

def test_analyze_sentiment_cached():
    mock_analyzer = Mock()
    mock_cache = Mock()
    mock_cache.get.return_value = ""positive""
    result = analyze_sentiment(""Cached text"", mock_analyzer, mock_cache)
    assert result == ""positive""
    mock_analyzer.analyze.assert_not_called()

def test_analyze_sentiment_empty_text():
    mock_analyzer = Mock()
    mock_cache = Mock()
    with pytest.raises(ValueError):
        analyze_sentiment("""", mock_analyzer, mock_cache)",,