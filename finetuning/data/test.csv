"question","answer"
"class FileUploader:
    def upload_file(
        self,
        file_path: str,
        destination: str,
        storage_client,
        validator: Callable[[bytes], bool],
        logger: logging.Logger,
        chunk_size: int = 1024 * 1024,
    ) -> str:
        """"""Uploads a local file to a remote storage service in chunks.

        Args:
            file_path: Absolute path to the file on the local filesystem.
            destination: Remote path (including bucket/container) where the file should be stored.
            storage_client: Object exposing ``initiate_upload(dest: str) -> UploadSession`` where
                ``UploadSession`` provides ``upload_chunk(data: bytes) -> None`` and ``finalize() -> str``.
                The ``finalize`` method returns the URL of the uploaded file.
            validator: Callable that receives the raw bytes of a chunk and returns ``True`` if the
                chunk is considered valid (e.g., passes virus scan). May raise ``ValidationError``.
            logger: Logger with ``info(message: str)`` and ``error(message: str)`` methods.
            chunk_size: Size of each read chunk in bytes; defaults to 1 MiB. Must be a positive integer.

        Returns:
            The remote URL of the uploaded file as returned by ``UploadSession.finalize``.

        Raises:
            FileNotFoundError: If ``file_path`` does not point to an existing file.
            ValueError: If ``chunk_size`` is not a positive integer.
            ValidationError: Propagated when ``validator`` flags a chunk as invalid.
            StorageError: Propagated if any ``storage_client`` operation fails.

        Dependencies:
            - storage_client: Provides ``initiate_upload`` returning an object with ``upload_chunk`` and
              ``finalize`` methods; may raise ``StorageError``.
            - validator: Callable[[bytes], bool] that may raise ``ValidationError``.
            - logger: Logging instance for progress reporting.
        """"""
        ...

# Dependency specifications
# - storage_client: ``initiate_upload(dest) -> UploadSession``; ``UploadSession`` has ``upload_chunk(data)`` and ``finalize() -> str``; may raise ``StorageError``.
# - validator: Callable[[bytes], bool]; may raise ``ValidationError``.
# - logger: ``info(message)`` and ``error(message)`` methods.","import pytest
from unittest.mock import MagicMock, mock_open, patch
import importlib

module = importlib.import_module(""file_uploader_module"")
FileUploader = getattr(module, ""FileUploader"")
ValidationError = getattr(module, ""ValidationError"", Exception)
StorageError = getattr(module, ""StorageError"", Exception)


@pytest.fixture
def uploader():
    return FileUploader()


@pytest.fixture
def storage_client():
    client = MagicMock()
    session = MagicMock()
    client.initiate_upload.return_value = session
    session.upload_chunk.return_value = None
    session.finalize.return_value = ""https://storage.example.com/file""
    return client


@pytest.fixture
def validator():
    return MagicMock(return_value=True)


@pytest.fixture
def logger():
    return MagicMock()


def _mock_file(content: bytes, chunk_size: int):
    # Simulate a file object that yields chunks of the given size
    def read_side_effect(size=-1):
        nonlocal content
        if size == -1:
            data = content
            content = b""""
            return data
        data = content[:size]
        content = content[size:]
        return data

    file_mock = mock_open(read_data=b"""").return_value
    file_mock.__enter__.return_value = file_mock
    file_mock.read.side_effect = read_side_effect
    return file_mock


def test_upload_file_happy_path(uploader, storage_client, validator, logger):
    file_content = b""abcdefghijklmnopqrstuvwxyz"" * 100  # 2600 bytes
    chunk_size = 1024
    file_mock = _mock_file(file_content, chunk_size)

    with patch(""builtins.open"", file_mock):
        url = uploader.upload_file(
            file_path=""/tmp/test.bin"",
            destination=""bucket/path/file.bin"",
            storage_client=storage_client,
            validator=validator,
            logger=logger,
            chunk_size=chunk_size,
        )

    assert url == ""https://storage.example.com/file""
    # Initiate upload called once with destination
    storage_client.initiate_upload.assert_called_once_with(""bucket/path/file.bin"")
    session = storage_client.initiate_upload.return_value
    # upload_chunk called for each full chunk (ceil division)
    expected_calls = (len(file_content) + chunk_size - 1) // chunk_size
    assert session.upload_chunk.call_count == expected_calls
    # finalize called once
    session.finalize.assert_called_once()
    # validator called for each chunk
    assert validator.call_count == expected_calls
    logger.info.assert_called()


def test_upload_file_invalid_chunk_size_raises(uploader, storage_client, validator, logger):
    with pytest.raises(ValueError):
        uploader.upload_file(
            file_path=""/tmp/any"",
            destination=""dest"",
            storage_client=storage_client,
            validator=validator,
            logger=logger,
            chunk_size=0,
        )
    logger.error.assert_called()


def test_upload_file_file_not_found_raises(uploader, storage_client, validator, logger):
    with patch(""builtins.open"", side_effect=FileNotFoundError):
        with pytest.raises(FileNotFoundError):
            uploader.upload_file(
                file_path=""/nonexistent"",
                destination=""dest"",
                storage_client=storage_client,
                validator=validator,
                logger=logger,
                chunk_size=1024,
            )
    logger.error.assert_called()


def test_upload_file_validator_raises(uploader, storage_client, logger):
    validator = MagicMock(side_effect=ValidationError(""invalid chunk""))
    file_content = b""data"" * 10
    file_mock = _mock_file(file_content, 1024)

    with patch(""builtins.open"", file_mock):
        with pytest.raises(ValidationError):
            uploader.upload_file(
                file_path=""/tmp/file"",
                destination=""dest"",
                storage_client=storage_client,
                validator=validator,
                logger=logger,
                chunk_size=1024,
            )
    storage_client.initiate_upload.assert_not_called()
    logger.error.assert_called()


def test_upload_file_storage_error_on_initiate(uploader, validator, logger):
    storage_client = MagicMock()
    storage_client.initiate_upload.side_effect = StorageError(""initiate failed"")
    file_content = b""abc""
    file_mock = _mock_file(file_content, 1024)

    with patch(""builtins.open"", file_mock):
        with pytest.raises(StorageError):
            uploader.upload_file(
                file_path=""/tmp/file"",
                destination=""dest"",
                storage_client=storage_client,
                validator=validator,
                logger=logger,
                chunk_size=1024,
            )
    logger.error.assert_called()


def test_upload_file_storage_error_on_upload_chunk(uploader, storage_client, validator, logger):
    session = MagicMock()
    session.upload_chunk.side_effect = StorageError(""upload failed"")
    storage_client.initiate_upload.return_value = session
    file_content = b""1234567890""
    file_mock = _mock_file(file_content, 4)  # will cause multiple chunks

    with patch(""builtins.open"", file_mock):
        with pytest.raises(StorageError):
            uploader.upload_file(
                file_path=""/tmp/file"",
                destination=""dest"",
                storage_client=storage_client,
                validator=validator,
                logger=logger,
                chunk_size=4,
            )
    # Ensure initiate called before failure
    storage_client.initiate_upload.assert_called_once_with(""dest"")
    logger.error.assert_called()"
"async def schedule_report_generation(
    report_name: str,
    parameters: Dict[str, Any],
    schedule_time: datetime.datetime,
    scheduler_client,
    db: Database,
    config: Mapping[str, Any],
    *,
    retry_attempts: int = 3,
) -> str:
    """"""Schedules a background report generation job to run at a specific time.

    Args:
        report_name: Identifier of the report template to use.
        parameters: Mapping of parameter names to values required by the report.
        schedule_time: Datetime (timezone‑aware) when the job should be triggered.
        scheduler_client: Async client exposing ``create_job(name: str, run_at: datetime, payload: dict) -> Job``.
            ``Job`` objects have an ``id`` attribute (str) and a ``status`` property.
        db: Database abstraction with an async ``save_job_metadata(job_id: str, info: dict) -> None`` method.
        config: Mapping providing configuration values such as ``MAX_RETRY`` (int) and ``DEFAULT_TTL`` (int seconds).
        retry_attempts: Number of times to retry job creation on transient failures; defaults to 3.

    Returns:
        The identifier of the created job as a string.

    Raises:
        ValueError: If ``schedule_time`` is in the past or ``retry_attempts`` is negative.
        SchedulerError: Propagated if the scheduler client fails to create the job after retries.
        DatabaseError: Propagated if storing job metadata fails.

    Dependencies:
        - scheduler_client: Async interface with ``create_job``; may raise ``SchedulerError``.
        - db (Database): Async ``save_job_metadata`` method; may raise ``DatabaseError``.
        - config: Provides ``MAX_RETRY`` and ``DEFAULT_TTL`` values used internally.
    """"""
    ...

# Dependency specifications
# - scheduler_client: async ``create_job(name, run_at, payload) -> Job``; ``Job`` has ``id`` (str) and ``status``; may raise ``SchedulerError``.
# - db (Database): async ``save_job_metadata(job_id, info)``; may raise ``DatabaseError``.
# - config: Mapping with ``MAX_RETRY`` (int) and ``DEFAULT_TTL`` (int).","import pytest
from unittest.mock import AsyncMock, MagicMock, call
import importlib
import datetime

module = importlib.import_module(""target_module"")
schedule_report_generation = getattr(module, ""schedule_report_generation"")
SchedulerError = getattr(module, ""SchedulerError"", Exception)
DatabaseError = getattr(module, ""DatabaseError"", Exception)


@pytest.fixture
def mock_scheduler_client():
    client = MagicMock()
    client.create_job = AsyncMock()
    return client


@pytest.fixture
def mock_db():
    db = MagicMock()
    db.save_job_metadata = AsyncMock()
    return db


@pytest.fixture
def config():
    return {""MAX_RETRY"": 5, ""DEFAULT_TTL"": 3600}


@pytest.mark.asyncio
async def test_schedule_report_generation_success(mock_scheduler_client, mock_db, config):
    report_name = ""sales_report""
    parameters = {""region"": ""EU"", ""year"": 2023}
    schedule_time = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(hours=1)

    job = MagicMock()
    job.id = ""job-001""
    job.status = ""scheduled""
    mock_scheduler_client.create_job.return_value = job

    result = await schedule_report_generation(
        report_name,
        parameters,
        schedule_time,
        scheduler_client=mock_scheduler_client,
        db=mock_db,
        config=config,
    )

    assert result == job.id
    mock_scheduler_client.create_job.assert_awaited_once_with(
        name=report_name, run_at=schedule_time, payload=parameters
    )
    mock_db.save_job_metadata.assert_awaited_once_with(job.id, {""report_name"": report_name, ""status"": job.status})


@pytest.mark.asyncio
async def test_schedule_report_generation_past_time_raises(mock_scheduler_client, mock_db, config):
    report_name = ""inventory_report""
    parameters = {}
    past_time = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(days=1)

    with pytest.raises(ValueError):
        await schedule_report_generation(
            report_name,
            parameters,
            past_time,
            scheduler_client=mock_scheduler_client,
            db=mock_db,
            config=config,
        )

    mock_scheduler_client.create_job.assert_not_called()
    mock_db.save_job_metadata.assert_not_called()


@pytest.mark.asyncio
async def test_schedule_report_generation_negative_retry_raises(mock_scheduler_client, mock_db, config):
    report_name = ""audit_report""
    parameters = {}
    schedule_time = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(minutes=10)

    with pytest.raises(ValueError):
        await schedule_report_generation(
            report_name,
            parameters,
            schedule_time,
            scheduler_client=mock_scheduler_client,
            db=mock_db,
            config=config,
            retry_attempts=-1,
        )

    mock_scheduler_client.create_job.assert_not_called()
    mock_db.save_job_metadata.assert_not_called()


@pytest.mark.asyncio
async def test_schedule_report_generation_retry_success(mock_scheduler_client, mock_db, config):
    report_name = ""finance_report""
    parameters = {""quarter"": ""Q1""}
    schedule_time = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(minutes=5)

    job = MagicMock()
    job.id = ""job-xyz""
    job.status = ""scheduled""
    # First attempt fails, second succeeds
    mock_scheduler_client.create_job.side_effect = [SchedulerError(""transient""), job]

    result = await schedule_report_generation(
        report_name,
        parameters,
        schedule_time,
        scheduler_client=mock_scheduler_client,
        db=mock_db,
        config=config,
        retry_attempts=2,
    )

    assert result == job.id
    assert mock_scheduler_client.create_job.await_count == 2
    mock_db.save_job_metadata.assert_awaited_once_with(job.id, {""report_name"": report_name, ""status"": job.status})


@pytest.mark.asyncio
async def test_schedule_report_generation_retry_exhausted(mock_scheduler_client, mock_db, config):
    report_name = ""ops_report""
    parameters = {}
    schedule_time = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(minutes=15)

    mock_scheduler_client.create_job.side_effect = SchedulerError(""persistent failure"")

    with pytest.raises(SchedulerError):
        await schedule_report_generation(
            report_name,
            parameters,
            schedule_time,
            scheduler_client=mock_scheduler_client,
            db=mock_db,
            config=config,
            retry_attempts=3,
        )

    assert mock_scheduler_client.create_job.await_count == 3
    mock_db.save_job_metadata.assert_not_called()


@pytest.mark.asyncio
async def test_schedule_report_generation_db_error_propagates(mock_scheduler_client, mock_db, config):
    report_name = ""hr_report""
    parameters = {""department"": ""Recruiting""}
    schedule_time = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(hours=2)

    job = MagicMock()
    job.id = ""job-777""
    job.status = ""scheduled""
    mock_scheduler_client.create_job.return_value = job
    mock_db.save_job_metadata.side_effect = DatabaseError(""db failure"")

    with pytest.raises(DatabaseError):
        await schedule_report_generation(
            report_name,
            parameters,
            schedule_time,
            scheduler_client=mock_scheduler_client,
            db=mock_db,
            config=config,
        )

    mock_scheduler_client.create_job.assert_awaited_once_with(
        name=report_name, run_at=schedule_time, payload=parameters
    )
    mock_db.save_job_metadata.assert_awaited_once_with(job.id, {""report_name"": report_name, ""status"": job.status})"
"def generate_invoice(order_id: int, db, template_renderer):
    """"""Generates a PDF invoice for a given order.

    Args:
        order_id (int): Unique identifier of the order to invoice.
        db: Database abstraction exposing ``get_order(order_id)`` which returns a dict
            with keys ``customer_name``, ``items`` (list of dicts with ``name`` and ``price``),
            and ``total`` (float). May raise ``DatabaseError``.
        template_renderer: Service with a ``render(template_name: str, context: dict) -> str``
            method that returns HTML content for the invoice.

    Returns:
        bytes: Binary PDF data representing the rendered invoice.

    Raises:
        ValueError: If ``order_id`` is not a positive integer.
        DatabaseError: Propagated from the ``db`` layer when the order cannot be retrieved.
        RenderingError: If the template rendering fails.

    Dependencies:
        - logger (logging.Logger): Used to log start and completion of invoice generation.
        - pdf_converter (PdfConverter): Provides ``convert_html_to_pdf(html: str) -> bytes``.
    """"""","import pytest
from unittest.mock import MagicMock, patch

import importlib

invoice_module = importlib.import_module(""invoice_module"")
generate_invoice = invoice_module.generate_invoice
DatabaseError = getattr(invoice_module, ""DatabaseError"", Exception)
RenderingError = getattr(invoice_module, ""RenderingError"", Exception)


def test_generate_invoice_success():
    order_id = 42
    order_data = {
        ""customer_name"": ""John Doe"",
        ""items"": [{""name"": ""Item A"", ""price"": 10.0}, {""name"": ""Item B"", ""price"": 20.0}],
        ""total"": 30.0,
    }
    html_content = ""<html>Invoice</html>""
    pdf_bytes = b""%PDF-1.4 mock pdf bytes%""

    mock_db = MagicMock()
    mock_db.get_order.return_value = order_data

    mock_renderer = MagicMock()
    mock_renderer.render.return_value = html_content

    mock_logger = MagicMock()
    mock_pdf_converter = MagicMock()
    mock_pdf_converter.convert_html_to_pdf.return_value = pdf_bytes

    with patch.object(invoice_module, ""logger"", mock_logger), patch.object(
        invoice_module, ""pdf_converter"", mock_pdf_converter
    ):
        result = generate_invoice(order_id, mock_db, mock_renderer)

    assert result == pdf_bytes
    mock_db.get_order.assert_called_once_with(order_id)
    mock_renderer.render.assert_called_once()
    rendered_template, context = mock_renderer.render.call_args[0]
    assert isinstance(rendered_template, str)
    assert isinstance(context, dict)
    assert context.get(""order"") == order_data
    mock_pdf_converter.convert_html_to_pdf.assert_called_once_with(html_content)
    mock_logger.info.assert_called()


@pytest.mark.parametrize(""invalid_id"", [0, -1, -100])
def test_generate_invoice_invalid_order_id(invalid_id):
    mock_db = MagicMock()
    mock_renderer = MagicMock()
    with pytest.raises(ValueError):
        generate_invoice(invalid_id, mock_db, mock_renderer)


def test_generate_invoice_database_error():
    order_id = 7
    mock_db = MagicMock()
    mock_db.get_order.side_effect = DatabaseError(""cannot fetch"")
    mock_renderer = MagicMock()
    with pytest.raises(DatabaseError):
        generate_invoice(order_id, mock_db, mock_renderer)
    mock_db.get_order.assert_called_once_with(order_id)


def test_generate_invoice_rendering_error():
    order_id = 8
    order_data = {
        ""customer_name"": ""Jane Smith"",
        ""items"": [],
        ""total"": 0.0,
    }
    mock_db = MagicMock()
    mock_db.get_order.return_value = order_data

    mock_renderer = MagicMock()
    mock_renderer.render.side_effect = RenderingError(""render failure"")

    with pytest.raises(RenderingError):
        generate_invoice(order_id, mock_db, mock_renderer)

    mock_db.get_order.assert_called_once_with(order_id)
    mock_renderer.render.assert_called_once()"
"class FileUploader:
    async def upload_file(
        self,
        file_path: str,
        storage_client,
        virus_scanner,
        audit_logger,
        *,
        max_size_mb: int = 50,
        metadata: dict | None = None,
    ) -> str:
        """"""Uploads a file to remote cloud storage after scanning for viruses and records the operation.

        Args:
            file_path: Path to the local file to be uploaded. Must point to an existing readable file.
            storage_client: Async client exposing ``upload(path: str, data: bytes, metadata: dict | None) -> str``
                which returns the remote URL of the stored object. May raise ``StorageError``.
            virus_scanner: Service with an async ``scan(data: bytes) -> bool`` method that returns ``True``
                if the file is clean. May raise ``ScannerError``.
            audit_logger: Logger with async ``log(event: str, details: dict) -> None`` used for audit trails.
            max_size_mb: Maximum allowed file size in megabytes. Files exceeding this limit cause a ``FileSizeError``.
            metadata: Optional dictionary of metadata to attach to the uploaded object.

        Returns:
            The URL (string) of the uploaded file in the cloud storage.

        Raises:
            FileNotFoundError: If ``file_path`` does not exist.
            FileSizeError: If the file size exceeds ``max_size_mb``.
            ScannerError: Propagated from ``virus_scanner`` when scanning fails.
            ValueError: If the virus scanner reports the file as infected.
            StorageError: Propagated from ``storage_client`` if the upload fails.
            Exception: Any unexpected error from ``audit_logger`` is propagated.

        Dependencies:
            - storage_client: Async client for uploading data.
            - virus_scanner: Async service for virus scanning.
            - audit_logger: Async logger for audit events.
        """"""

# Dependency specifications
# - storage_client: async ``upload(path: str, data: bytes, metadata: dict | None) -> str``; may raise ``StorageError``.
# - virus_scanner: async ``scan(data: bytes) -> bool``; may raise ``ScannerError``.
# - audit_logger: async ``log(event: str, details: dict) -> None``; may raise generic ``Exception``.","import pytest
from unittest.mock import MagicMock, AsyncMock
import importlib

module = importlib.import_module(""file_uploader"")
FileUploader = getattr(module, ""FileUploader"")
FileSizeError = getattr(module, ""FileSizeError"", Exception)
StorageError = getattr(module, ""StorageError"", Exception)
ScannerError = getattr(module, ""ScannerError"", Exception)


@pytest.fixture
def uploader():
    return FileUploader()


@pytest.fixture
def mock_storage_client():
    client = MagicMock()
    client.upload = AsyncMock()
    return client


@pytest.fixture
def mock_virus_scanner():
    scanner = MagicMock()
    scanner.scan = AsyncMock()
    return scanner


@pytest.fixture
def mock_audit_logger():
    logger = MagicMock()
    logger.log = AsyncMock()
    return logger


@pytest.mark.asyncio
async def test_upload_file_success(
    uploader,
    mock_storage_client,
    mock_virus_scanner,
    mock_audit_logger,
    tmp_path,
):
    data = b""hello world""
    file_path = tmp_path / ""file.txt""
    file_path.write_bytes(data)

    mock_virus_scanner.scan.return_value = True
    mock_storage_client.upload.return_value = ""https://storage.example/file.txt""

    url = await uploader.upload_file(
        str(file_path),
        mock_storage_client,
        mock_virus_scanner,
        mock_audit_logger,
        max_size_mb=1,
        metadata={""owner"": ""test""},
    )

    assert url == ""https://storage.example/file.txt""
    mock_virus_scanner.scan.assert_awaited_once_with(data)
    mock_storage_client.upload.assert_awaited_once_with(
        str(file_path), data, {""owner"": ""test""}
    )
    mock_audit_logger.log.assert_awaited_once()


@pytest.mark.asyncio
async def test_upload_file_not_found(
    uploader,
    mock_storage_client,
    mock_virus_scanner,
    mock_audit_logger,
):
    non_existent_path = ""/non/existent/file.txt""
    with pytest.raises(FileNotFoundError):
        await uploader.upload_file(
            non_existent_path,
            mock_storage_client,
            mock_virus_scanner,
            mock_audit_logger,
        )
    mock_virus_scanner.scan.assert_not_called()
    mock_storage_client.upload.assert_not_called()
    mock_audit_logger.log.assert_not_called()


@pytest.mark.asyncio
async def test_upload_file_exceeds_size(
    uploader,
    mock_storage_client,
    mock_virus_scanner,
    mock_audit_logger,
    tmp_path,
):
    oversized_data = b""a"" * (2 * 1024 * 1024)  # 2 MiB
    file_path = tmp_path / ""big.bin""
    file_path.write_bytes(oversized_data)

    with pytest.raises(FileSizeError):
        await uploader.upload_file(
            str(file_path),
            mock_storage_client,
            mock_virus_scanner,
            mock_audit_logger,
            max_size_mb=1,  # 1 MiB limit
        )
    mock_virus_scanner.scan.assert_not_called()
    mock_storage_client.upload.assert_not_called()
    mock_audit_logger.log.assert_not_called()


@pytest.mark.asyncio
async def test_upload_file_infected(
    uploader,
    mock_storage_client,
    mock_virus_scanner,
    mock_audit_logger,
    tmp_path,
):
    data = b""malicious content""
    file_path = tmp_path / ""infected.txt""
    file_path.write_bytes(data)

    mock_virus_scanner.scan.return_value = False

    with pytest.raises(ValueError):
        await uploader.upload_file(
            str(file_path),
            mock_storage_client,
            mock_virus_scanner,
            mock_audit_logger,
        )
    mock_virus_scanner.scan.assert_awaited_once_with(data)
    mock_storage_client.upload.assert_not_called()
    mock_audit_logger.log.assert_not_called()


@pytest.mark.asyncio
async def test_upload_file_scanner_error(
    uploader,
    mock_storage_client,
    mock_virus_scanner,
    mock_audit_logger,
    tmp_path,
):
    data = b""some data""
    file_path = tmp_path / ""file.txt""
    file_path.write_bytes(data)

    mock_virus_scanner.scan.side_effect = ScannerError(""scan failed"")

    with pytest.raises(ScannerError):
        await uploader.upload_file(
            str(file_path),
            mock_storage_client,
            mock_virus_scanner,
            mock_audit_logger,
        )
    mock_virus_scanner.scan.assert_awaited_once_with(data)
    mock_storage_client.upload.assert_not_called()
    mock_audit_logger.log.assert_not_called()


@pytest.mark.asyncio
async def test_upload_file_storage_error(
    uploader,
    mock_storage_client,
    mock_virus_scanner,
    mock_audit_logger,
    tmp_path,
):
    data = b""valid content""
    file_path = tmp_path / ""file.txt""
    file_path.write_bytes(data)

    mock_virus_scanner.scan.return_value = True
    mock_storage_client.upload.side_effect = StorageError(""upload failed"")

    with pytest.raises(StorageError):
        await uploader.upload_file(
            str(file_path),
            mock_storage_client,
            mock_virus_scanner,
            mock_audit_logger,
        )
    mock_virus_scanner.scan.assert_awaited_once_with(data)
    mock_storage_client.upload.assert_awaited_once_with(str(file_path), data, None)
    mock_audit_logger.log.assert_not_called()


@pytest.mark.asyncio
async def test_upload_file_audit_logger_exception(
    uploader,
    mock_storage_client,
    mock_virus_scanner,
    mock_audit_logger,
    tmp_path,
):
    data = b""clean file""
    file_path = tmp_path / ""file.txt""
    file_path.write_bytes(data)

    mock_virus_scanner.scan.return_value = True
    mock_storage_client.upload.return_value = ""https://storage.example/file.txt""
    mock_audit_logger.log.side_effect = Exception(""audit failure"")

    with pytest.raises(Exception) as exc:
        await uploader.upload_file(
            str(file_path),
            mock_storage_client,
            mock_virus_scanner,
            mock_audit_logger,
        )
    assert ""audit failure"" in str(exc.value)

    mock_virus_scanner.scan.assert_awaited_once_with(data)
    mock_storage_client.upload.assert_awaited_once_with(str(file_path), data, None)
    mock_audit_logger.log.assert_awaited_once()"
"class DataIngestionService:
    def ingest_records(
        self,
        source: str,
        batch_size: int,
        db_client,
        api_client,
        cache: Optional[Cache] = None,
        metrics: Optional[MetricsCollector] = None,
    ) -> int:
        """"""Ingests records from an external API into the database in batches.

        Args:
            source: Identifier of the data source (e.g., ``""sales_api""``). Must be a non‑empty string.
            batch_size: Number of records to fetch and insert per transaction. Must be a positive integer.
            db_client: Object exposing ``bulk_insert(table: str, rows: List[dict]) -> None``.
                May raise ``DatabaseError``.
            api_client: Service providing ``fetch_records(source: str, limit: int, offset: int) -> List[dict]``.
                May raise ``ApiError``.
            cache (optional): Cache abstraction with ``get(key: str) -> Any`` and ``set(key: str, value: Any, ttl: int)``.
                Used to store the last processed offset for each source. May raise ``CacheError``.
            metrics (optional): Collector with ``increment(metric_name: str, value: int = 1)`` used for
                tracking ``records_ingested`` and ``ingestion_errors``.

        Returns:
            The total number of records successfully ingested.

        Raises:
            ValueError: If ``source`` is empty or ``batch_size`` is non‑positive.
            ApiError: Propagated when ``api_client.fetch_records`` fails.
            DatabaseError: Propagated if ``db_client.bulk_insert`` fails.
            CacheError: Propagated if cache operations fail.

        Dependencies:
            - db_client: method ``bulk_insert(table: str, rows: List[dict]) -> None`` may raise ``DatabaseError``.
            - api_client: method ``fetch_records(source: str, limit: int, offset: int) -> List[dict]`` may raise ``ApiError``.
            - cache (optional): methods ``get`` and ``set`` may raise ``CacheError``.
            - metrics (optional): method ``increment(metric_name: str, value: int = 1)`` for observability.
        """"""
        ...

# Dependency specifications
# - db_client: ``bulk_insert`` inserts rows; raises ``DatabaseError``.
# - api_client: ``fetch_records`` returns list of dicts; raises ``ApiError``.
# - cache (optional): ``get``/``set`` for offset tracking; may raise ``CacheError``.
# - metrics (optional): ``increment`` used for counting ingested records and errors.","import pytest
from unittest.mock import MagicMock, call
import importlib

module = importlib.import_module(""data_ingestion"")
DataIngestionService = getattr(module, ""DataIngestionService"")
DatabaseError = getattr(module, ""DatabaseError"", Exception)
ApiError = getattr(module, ""ApiError"", Exception)
CacheError = getattr(module, ""CacheError"", Exception)


@pytest.fixture
def service():
    return DataIngestionService()


@pytest.fixture
def mock_db_client():
    return MagicMock()


@pytest.fixture
def mock_api_client():
    return MagicMock()


@pytest.fixture
def mock_cache():
    return MagicMock()


@pytest.fixture
def mock_metrics():
    return MagicMock()


def test_ingest_records_success_with_cache_and_metrics(
    service,
    mock_db_client,
    mock_api_client,
    mock_cache,
    mock_metrics,
):
    # Setup cache to start from offset 0
    mock_cache.get.return_value = 0

    # First fetch returns 2 records, second fetch returns empty list (termination)
    first_batch = [{""id"": 1}, {""id"": 2}]
    mock_api_client.fetch_records.side_effect = [first_batch, []]

    total = service.ingest_records(
        source=""sales_api"",
        batch_size=2,
        db_client=mock_db_client,
        api_client=mock_api_client,
        cache=mock_cache,
        metrics=mock_metrics,
    )

    assert total == 2
    # Verify fetch calls (offset increments)
    expected_fetch_calls = [
        call(""sales_api"", 2, 0),
        call(""sales_api"", 2, 2),
    ]
    assert mock_api_client.fetch_records.call_args_list == expected_fetch_calls
    # Verify bulk insert called with the fetched rows
    mock_db_client.bulk_insert.assert_called_once()
    args, _ = mock_db_client.bulk_insert.call_args
    assert isinstance(args[0], str)  # table name
    assert args[1] == first_batch
    # Cache should store new offset
    mock_cache.get.assert_called_once_with(""sales_api_offset"")
    mock_cache.set.assert_called_once_with(""sales_api_offset"", 2, ttl=ANY)
    # Metrics for successful ingest
    mock_metrics.increment.assert_any_call(""records_ingested"", value=2)
    # No error metric increment
    for call_args in mock_metrics.increment.call_args_list:
        assert call_args[0][0] != ""ingestion_errors""


def test_ingest_records_success_without_optional_dependencies(
    service,
    mock_db_client,
    mock_api_client,
):
    mock_api_client.fetch_records.side_effect = [[{""id"": 10}], []]

    total = service.ingest_records(
        source=""inventory_api"",
        batch_size=5,
        db_client=mock_db_client,
        api_client=mock_api_client,
        cache=None,
        metrics=None,
    )

    assert total == 1
    mock_api_client.fetch_records.assert_called_once_with(""inventory_api"", 5, 0)
    mock_db_client.bulk_insert.assert_called_once()
    # Ensure no cache interaction
    # Ensure no metrics interaction (cannot assert directly as they are None)


@pytest.mark.parametrize(""source"", ["""", None])
def test_ingest_records_invalid_source_raises(
    service,
    mock_db_client,
    mock_api_client,
    source,
):
    with pytest.raises(ValueError):
        service.ingest_records(
            source=source,
            batch_size=10,
            db_client=mock_db_client,
            api_client=mock_api_client,
        )


@pytest.mark.parametrize(""batch_size"", [0, -1])
def test_ingest_records_invalid_batch_size_raises(
    service,
    mock_db_client,
    mock_api_client,
    batch_size,
):
    with pytest.raises(ValueError):
        service.ingest_records(
            source=""valid_source"",
            batch_size=batch_size,
            db_client=mock_db_client,
            api_client=mock_api_client,
        )


def test_ingest_records_api_error_propagates(
    service,
    mock_db_client,
    mock_api_client,
    mock_metrics,
):
    mock_api_client.fetch_records.side_effect = ApiError(""api failure"")
    mock_metrics.increment = MagicMock()

    with pytest.raises(ApiError):
        service.ingest_records(
            source=""sales_api"",
            batch_size=10,
            db_client=mock_db_client,
            api_client=mock_api_client,
            cache=None,
            metrics=mock_metrics,
        )

    mock_metrics.increment.assert_any_call(""ingestion_errors"", value=1)


def test_ingest_records_database_error_propagates(
    service,
    mock_db_client,
    mock_api_client,
    mock_metrics,
):
    mock_api_client.fetch_records.return_value = [{""id"": 1}]
    mock_db_client.bulk_insert.side_effect = DatabaseError(""db failure"")
    mock_metrics.increment = MagicMock()

    with pytest.raises(DatabaseError):
        service.ingest_records(
            source=""sales_api"",
            batch_size=10,
            db_client=mock_db_client,
            api_client=mock_api_client,
            cache=None,
            metrics=mock_metrics,
        )

    mock_metrics.increment.assert_any_call(""ingestion_errors"", value=1)


def test_ingest_records_cache_get_error_propagates(
    service,
    mock_db_client,
    mock_api_client,
    mock_cache,
):
    mock_cache.get.side_effect = CacheError(""cache read failure"")

    with pytest.raises(CacheError):
        service.ingest_records(
            source=""sales_api"",
            batch_size=10,
            db_client=mock_db_client,
            api_client=mock_api_client,
            cache=mock_cache,
            metrics=None,
        )


def test_ingest_records_cache_set_error_propagates(
    service,
    mock_db_client,
    mock_api_client,
    mock_cache,
    mock_metrics,
):
    mock_cache.get.return_value = 0
    mock_api_client.fetch_records.side_effect = [[{""id"": 1}], []]
    mock_cache.set.side_effect = CacheError(""cache write failure"")
    mock_metrics.increment = MagicMock()

    with pytest.raises(CacheError):
        service.ingest_records(
            source=""sales_api"",
            batch_size=10,
            db_client=mock_db_client,
            api_client=mock_api_client,
            cache=mock_cache,
            metrics=mock_metrics,
        )

    mock_metrics.increment.assert_any_call(""ingestion_errors"", value=1)"
"async def fetch_user_profile(user_id: str, api_client) -> dict:
    """"""Retrieves a user profile from a remote service.

    Args:
        user_id: Identifier of the user whose profile is requested. Must be a non‑empty string.
        api_client: Asynchronous client exposing ``get(path: str, params: dict) -> Awaitable[dict]``.
            The ``get`` method may raise ``NetworkError`` on connectivity issues or ``HttpError`` for non‑2xx responses.

    Returns:
        A dictionary containing the user profile data as returned by the remote service.

    Raises:
        ValueError: If ``user_id`` is empty.
        NetworkError: Propagated when ``api_client.get`` cannot reach the service.
        HttpError: Propagated when the remote service returns an error status.

    Dependencies:
        - api_client: async ``get`` method used to fetch the profile.
    """"""
    ...","import pytest
from unittest.mock import AsyncMock, MagicMock
import importlib

module = importlib.import_module(""user_module"")
fetch_user_profile = getattr(module, ""fetch_user_profile"")
NetworkError = getattr(module, ""NetworkError"", Exception)
HttpError = getattr(module, ""HttpError"", Exception)


@pytest.fixture
def api_client():
    client = MagicMock()
    client.get = AsyncMock()
    return client


@pytest.mark.asyncio
async def test_fetch_user_profile_happy_path(api_client):
    user_id = ""user_123""
    expected_profile = {""id"": user_id, ""name"": ""Alice""}
    api_client.get.return_value = expected_profile

    result = await fetch_user_profile(user_id, api_client)

    assert result == expected_profile
    api_client.get.assert_awaited_once_with(f""/users/{user_id}"", {})


@pytest.mark.asyncio
async def test_fetch_user_profile_invalid_user_id_raises():
    with pytest.raises(ValueError):
        await fetch_user_profile("""", MagicMock())


@pytest.mark.asyncio
async def test_fetch_user_profile_network_error_propagates(api_client):
    api_client.get.side_effect = NetworkError(""connection lost"")
    with pytest.raises(NetworkError):
        await fetch_user_profile(""user_456"", api_client)
    api_client.get.assert_awaited_once()


@pytest.mark.asyncio
async def test_fetch_user_profile_http_error_propagates(api_client):
    api_client.get.side_effect = HttpError(""404 Not Found"")
    with pytest.raises(HttpError):
        await fetch_user_profile(""user_789"", api_client)
    api_client.get.assert_awaited_once()"
"class FileStorageService:
    async def upload_file(
        self,
        file_path: str,
        storage_client,
        *,
        metadata: dict = None,
        retry_policy=None,
        logger: Optional[logging.Logger] = None,
    ) -> str:
        """"""Uploads a file to remote storage, optionally attaching metadata and applying retry logic.

        Args:
            file_path: Local filesystem path to the file to be uploaded.
            storage_client: Async client exposing ``upload(path: str, data: bytes, metadata: dict) -> str``
                which returns the remote file URL and may raise ``StorageError``.
            metadata (optional): Dictionary of metadata to store with the file.
            retry_policy (optional): Object with ``should_retry(exception) -> bool`` determining whether to retry on failure.
            logger (optional): Logger with ``info(message: str)`` and ``warning(message: str)`` methods.

        Returns:
            The URL of the uploaded file as returned by ``storage_client.upload``.

        Raises:
            FileNotFoundError: If ``file_path`` does not exist.
            StorageError: Propagated if the upload fails and the retry policy decides not to retry.
            ValueError: If ``file_path`` is an empty string.

        Dependencies:
            - storage_client: async ``upload`` method may raise ``StorageError``.
            - retry_policy (optional): ``should_retry(exception)`` for retry decisions.
            - logger (optional): ``info`` and ``warning`` for audit.
        """"""
        ...","import pytest
from unittest.mock import AsyncMock, MagicMock, mock_open, patch, call
import importlib
import logging

module = importlib.import_module(""file_storage_module"")
FileStorageService = getattr(module, ""FileStorageService"")
StorageError = getattr(module, ""StorageError"", Exception)


@pytest.fixture
def service():
    return FileStorageService()


@pytest.fixture
def storage_client():
    client = MagicMock()
    client.upload = AsyncMock()
    return client


@pytest.fixture
def logger():
    return MagicMock()


@pytest.fixture
def retry_policy():
    return MagicMock()


@pytest.mark.asyncio
async def test_upload_file_success(service, storage_client, logger):
    file_path = ""/tmp/file.txt""
    file_content = b""test data""
    expected_url = ""https://storage.example.com/file.txt""
    metadata = {""author"": ""alice""}

    storage_client.upload.return_value = expected_url

    m_open = mock_open(read_data=file_content)
    with patch(""os.path.isfile"", return_value=True), patch(""builtins.open"", m_open):
        result = await service.upload_file(
            file_path,
            storage_client=storage_client,
            metadata=metadata,
            logger=logger,
        )

    assert result == expected_url
    storage_client.upload.assert_awaited_once_with(file_path, file_content, metadata)
    logger.info.assert_called()


@pytest.mark.asyncio
async def test_upload_file_retry_success(service, storage_client, retry_policy, logger):
    file_path = ""/tmp/file.txt""
    file_content = b""retry data""
    expected_url = ""https://storage.example.com/file.txt""
    metadata = None

    # First attempt fails, second succeeds
    storage_client.upload.side_effect = [StorageError(""temp failure""), expected_url]
    retry_policy.should_retry.side_effect = [True, False]

    m_open = mock_open(read_data=file_content)
    with patch(""os.path.isfile"", return_value=True), patch(""builtins.open"", m_open):
        result = await service.upload_file(
            file_path,
            storage_client=storage_client,
            retry_policy=retry_policy,
            logger=logger,
        )

    assert result == expected_url
    assert storage_client.upload.await_count == 2
    retry_policy.should_retry.assert_called()
    logger.warning.assert_called()


@pytest.mark.asyncio
async def test_upload_file_retry_not_allowed(service, storage_client, retry_policy, logger):
    file_path = ""/tmp/file.txt""
    file_content = b""no retry""
    metadata = None

    storage_client.upload.side_effect = StorageError(""permanent failure"")
    retry_policy.should_retry.return_value = False

    m_open = mock_open(read_data=file_content)
    with patch(""os.path.isfile"", return_value=True), patch(""builtins.open"", m_open):
        with pytest.raises(StorageError):
            await service.upload_file(
                file_path,
                storage_client=storage_client,
                retry_policy=retry_policy,
                logger=logger,
            )

    storage_client.upload.assert_awaited_once()
    retry_policy.should_retry.assert_called_once()
    logger.warning.assert_not_called()


def test_upload_file_empty_path_raises_value_error(service, storage_client, logger):
    with pytest.raises(ValueError):
        pytest.run(asyncio.run(service.upload_file(
            """",
            storage_client=storage_client,
            logger=logger,
        )))


@pytest.mark.asyncio
async def test_upload_file_not_found(service, storage_client, logger):
    file_path = ""/nonexistent/file.txt""
    with patch(""os.path.isfile"", return_value=False):
        with pytest.raises(FileNotFoundError):
            await service.upload_file(
                file_path,
                storage_client=storage_client,
                logger=logger,
            )
    storage_client.upload.assert_not_awaited()
    logger.info.assert_not_called()"
"async def fetch_user_data(user_id, api_client):
    """"""Retrieves user profile data from a remote service.

    Args:
        user_id (str): Identifier of the user to fetch.
        api_client: An asynchronous HTTP client with a `get` coroutine method.

    Returns:
        dict: Parsed JSON response containing user details.

    Raises:
        ConnectionError: If the request fails due to network issues.
        ValueError: If the response status is not 200.

    Dependencies:
        - logger: a logging.Logger instance used to log request attempts.
    """"""","import pytest
from unittest.mock import AsyncMock, MagicMock, patch

# Assume the function is defined in a module named `my_module`
import importlib
my_module = importlib.import_module(""my_module"")
fetch_user_data = my_module.fetch_user_data


@pytest.mark.asyncio
async def test_fetch_user_data_success():
    user_id = ""user123""
    expected_data = {""id"": user_id, ""name"": ""Alice""}

    # Mock response object
    mock_response = MagicMock()
    mock_response.status = 200
    mock_response.json = AsyncMock(return_value=expected_data)

    # Mock api_client.get to return the mock response
    mock_api_client = MagicMock()
    mock_api_client.get = AsyncMock(return_value=mock_response)

    with patch.object(my_module, ""logger"") as mock_logger:
        result = await fetch_user_data(user_id, mock_api_client)

    assert result == expected_data
    mock_api_client.get.assert_awaited_once_with(f""/users/{user_id}"")
    mock_logger.info.assert_called()


@pytest.mark.asyncio
async def test_fetch_user_data_non_200():
    user_id = ""user456""

    mock_response = MagicMock()
    mock_response.status = 404
    mock_response.text = AsyncMock(return_value=""Not Found"")

    mock_api_client = MagicMock()
    mock_api_client.get = AsyncMock(return_value=mock_response)

    with patch.object(my_module, ""logger""):
        with pytest.raises(ValueError):
            await fetch_user_data(user_id, mock_api_client)


@pytest.mark.asyncio
async def test_fetch_user_data_connection_error():
    user_id = ""user789""

    mock_api_client = MagicMock()
    mock_api_client.get = AsyncMock(side_effect=ConnectionError)

    with patch.object(my_module, ""logger""):
        with pytest.raises(ConnectionError):
            await fetch_user_data(user_id, mock_api_client)"
"def send_email(
    recipient: str,
    subject: str,
    body: str,
    smtp_client: SmtpClient,
) -> bool:
    """"""Sends an email using the provided SMTP client.

    Args:
        recipient: Email address of the recipient. Must be a non‑empty string.
        subject: Subject line of the email.
        body: Plain‑text body of the email.
        smtp_client: Instance of ``SmtpClient`` exposing a ``send(to: str, subject: str, body: str) -> bool`` method.
            The method returns ``True`` on success and ``False`` on failure, and may raise ``SmtpError`` for
            connection problems.

    Returns:
        ``True`` if the email was sent successfully, otherwise ``False``.

    Raises:
        ValueError: If ``recipient`` is empty or does not contain an ``@`` symbol.
        SmtpError: Propagated if ``smtp_client.send`` raises an exception.

    Dependencies:
        - SmtpClient: method ``send(to: str, subject: str, body: str) -> bool``; may raise ``SmtpError``.
    """"""
    ...

# Dependency details
# - SmtpClient: ``send(to: str, subject: str, body: str) -> bool``; may raise ``SmtpError``.","import pytest
from unittest.mock import MagicMock

from email_module import send_email, SmtpError


@pytest.fixture
def smtp_client():
    client = MagicMock()
    client.send = MagicMock()
    return client


def test_send_email_success(smtp_client):
    smtp_client.send.return_value = True
    result = send_email(
        recipient=""user@example.com"",
        subject=""Test"",
        body=""Hello"",
        smtp_client=smtp_client,
    )
    assert result is True
    smtp_client.send.assert_called_once_with(
        ""user@example.com"", ""Test"", ""Hello""
    )


def test_send_email_failure(smtp_client):
    smtp_client.send.return_value = False
    result = send_email(
        recipient=""user@example.com"",
        subject=""Fail"",
        body=""Content"",
        smtp_client=smtp_client,
    )
    assert result is False
    smtp_client.send.assert_called_once_with(
        ""user@example.com"", ""Fail"", ""Content""
    )


def test_send_email_invalid_recipient_empty(smtp_client):
    with pytest.raises(ValueError):
        send_email(
            recipient="""",
            subject=""Subject"",
            body=""Body"",
            smtp_client=smtp_client,
        )
    smtp_client.send.assert_not_called()


def test_send_email_invalid_recipient_no_at(smtp_client):
    with pytest.raises(ValueError):
        send_email(
            recipient=""invalidemail.com"",
            subject=""Subject"",
            body=""Body"",
            smtp_client=smtp_client,
        )
    smtp_client.send.assert_not_called()


def test_send_email_smtp_error_propagates(smtp_client):
    smtp_client.send.side_effect = SmtpError()
    with pytest.raises(SmtpError):
        send_email(
            recipient=""user@example.com"",
            subject=""Error"",
            body=""Body"",
            smtp_client=smtp_client,
        )
    smtp_client.send.assert_called_once_with(
        ""user@example.com"", ""Error"", ""Body""
    )"
"def transform_data_batch(
    data: List[Dict[str, Any]],
    transformer: Callable[[Dict[str, Any]], Dict[str, Any]],
    db: Database,
    cache: Optional[Cache] = None,
    *,
    raise_on_invalid: bool = False,
) -> List[Dict[str, Any]]:
    """"""Applies a transformation function to a batch of records and persists the results.

    Args:
        data: A list of dictionaries representing raw records. Each record must contain at least
            an ``id`` key (int) and may contain arbitrary additional fields.
        transformer: Callable that takes a single record dict and returns a new dict. May raise
            ``TransformationError`` if the record cannot be transformed.
        db: Database abstraction exposing ``save(record: dict) -> None`` which may raise
            ``DatabaseError`` on failure.
        cache: Optional caching layer with ``set(key: str, value: Any, ttl: int)`` and ``get(key: str) -> Any``.
            When provided, transformed records should be cached using the record ``id`` as the key.
        raise_on_invalid: If ``True``, the function raises ``ValueError`` when a record lacks the required ``id``.
            If ``False``, such records are silently skipped.

    Returns:
        List of transformed record dictionaries that were successfully saved (and cached, if applicable).

    Raises:
        ValueError: If ``raise_on_invalid`` is ``True`` and any input record lacks an ``id`` key.
        TransformationError: Propagated when ``transformer`` fails for a particular record.
        DatabaseError: Propagated if ``db.save`` fails for a particular record.

    Dependencies:
        - Database: method ``save(record: dict)``; may raise ``DatabaseError``.
        - Cache (optional): methods ``set(key, value, ttl)`` and ``get(key)``; may raise ``CacheError``.
        - transformer: callable that may raise ``TransformationError``.
    """"""
    ...

# Dependency specifications
# - Database: ``save(record: dict)``; may raise ``DatabaseError``.
# - Cache (optional): ``set(key: str, value: Any, ttl: int)`` and ``get(key: str)``; may raise ``CacheError``.
# - transformer: Callable[[Dict[str, Any]], Dict[str, Any]]; may raise ``TransformationError``.","import pytest
from unittest.mock import MagicMock, call, patch

import importlib

module = importlib.import_module(""data_transformer"")
transform_data_batch = module.transform_data_batch
TransformationError = getattr(module, ""TransformationError"", Exception)
DatabaseError = getattr(module, ""DatabaseError"", Exception)
CacheError = getattr(module, ""CacheError"", Exception)


@pytest.fixture
def mock_db():
    return MagicMock()


@pytest.fixture
def mock_cache():
    return MagicMock()


@pytest.fixture
def mock_transformer():
    return MagicMock()


def test_transform_data_batch_success_with_cache(mock_db, mock_cache, mock_transformer):
    data = [{""id"": 1, ""value"": ""a""}, {""id"": 2, ""value"": ""b""}]
    transformed = [{""id"": 1, ""value"": ""A""}, {""id"": 2, ""value"": ""B""}]
    mock_transformer.side_effect = transformed

    result = transform_data_batch(
        data,
        mock_transformer,
        mock_db,
        cache=mock_cache,
        raise_on_invalid=False,
    )

    assert result == transformed
    assert mock_transformer.call_count == 2
    mock_db.save.assert_has_calls([call(transformed[0]), call(transformed[1])])
    assert mock_cache.set.call_count == 2
    mock_cache.set.assert_has_calls(
        [
            call(str(transformed[0][""id""]), transformed[0], ttl=ANY),
            call(str(transformed[1][""id""]), transformed[1], ttl=ANY),
        ]
    )


def test_transform_data_batch_success_without_cache(mock_db, mock_transformer):
    data = [{""id"": 3, ""value"": ""c""}]
    transformed = [{""id"": 3, ""value"": ""C""}]
    mock_transformer.return_value = transformed[0]

    result = transform_data_batch(
        data,
        mock_transformer,
        mock_db,
        cache=None,
        raise_on_invalid=False,
    )

    assert result == transformed
    mock_transformer.assert_called_once_with(data[0])
    mock_db.save.assert_called_once_with(transformed[0])


def test_transform_data_batch_skip_invalid_when_not_raising(mock_db, mock_transformer):
    data = [{""value"": ""no-id""}, {""id"": 4, ""value"": ""d""}]
    transformed = {""id"": 4, ""value"": ""D""}
    mock_transformer.return_value = transformed

    result = transform_data_batch(
        data,
        mock_transformer,
        mock_db,
        cache=None,
        raise_on_invalid=False,
    )

    assert result == [transformed]
    mock_transformer.assert_called_once_with(data[1])
    mock_db.save.assert_called_once_with(transformed)


def test_transform_data_batch_raises_value_error_on_invalid(mock_db, mock_transformer):
    data = [{""value"": ""no-id""}]

    with pytest.raises(ValueError):
        transform_data_batch(
            data,
            mock_transformer,
            mock_db,
            cache=None,
            raise_on_invalid=True,
        )


def test_transform_data_batch_propagates_transformation_error(mock_db, mock_transformer):
    data = [{""id"": 5, ""value"": ""e""}]
    mock_transformer.side_effect = TransformationError(""bad"")

    with pytest.raises(TransformationError):
        transform_data_batch(
            data,
            mock_transformer,
            mock_db,
            cache=None,
            raise_on_invalid=False,
        )
    mock_db.save.assert_not_called()


def test_transform_data_batch_propagates_database_error(mock_db, mock_transformer):
    data = [{""id"": 6, ""value"": ""f""}]
    mock_transformer.return_value = {""id"": 6, ""value"": ""F""}
    mock_db.save.side_effect = DatabaseError(""db fail"")

    with pytest.raises(DatabaseError):
        transform_data_batch(
            data,
            mock_transformer,
            mock_db,
            cache=None,
            raise_on_invalid=False,
        )
    mock_transformer.assert_called_once_with(data[0])


def test_transform_data_batch_propagates_cache_error(mock_db, mock_cache, mock_transformer):
    data = [{""id"": 7, ""value"": ""g""}]
    transformed = {""id"": 7, ""value"": ""G""}
    mock_transformer.return_value = transformed
    mock_cache.set.side_effect = CacheError(""cache fail"")

    with pytest.raises(CacheError):
        transform_data_batch(
            data,
            mock_transformer,
            mock_db,
            cache=mock_cache,
            raise_on_invalid=False,
        )
    mock_db.save.assert_called_once_with(transformed)"
"def process_payment(
    order_id: str,
    amount: float,
    currency: str,
    payment_gateway,
    logger=None,
) -> bool:
    """"""Processes a payment for a given order through an external gateway.

    Args:
        order_id: Unique identifier for the order to be charged.
        amount: Monetary amount to be transferred; must be greater than zero.
        currency: Three‑letter ISO currency code (e.g., ``'USD'``).
        payment_gateway: Service exposing ``charge(order_id: str, amount: float, currency: str) -> str``
            which returns a transaction ID or raises ``GatewayError``.
        logger (optional): ``logging.Logger`` used to record the transaction outcome.

    Returns:
        ``True`` if the charge was successful, ``False`` otherwise.

    Raises:
        ValueError: If ``amount`` is non‑positive or ``currency`` is unsupported.
        GatewayError: Propagated from ``payment_gateway`` when the charge fails.

    Dependencies:
        - payment_gateway: Provides ``charge`` method for external payment processing.
        - logger (optional): ``logging.Logger`` instance for audit logging.
    """"""","import pytest
from unittest.mock import MagicMock, patch

import importlib

module = importlib.import_module(""payment_processor"")
process_payment = getattr(module, ""process_payment"")
GatewayError = getattr(module, ""GatewayError"", Exception)


@pytest.fixture
def mock_gateway():
    return MagicMock()


@pytest.fixture
def mock_logger():
    return MagicMock()


def test_process_payment_success(mock_gateway, mock_logger):
    order_id = ""order-123""
    amount = 150.0
    currency = ""USD""
    mock_gateway.charge.return_value = ""txn-456""

    result = process_payment(
        order_id,
        amount,
        currency,
        payment_gateway=mock_gateway,
        logger=mock_logger,
    )

    assert result is True
    mock_gateway.charge.assert_called_once_with(order_id, amount, currency)
    mock_logger.info.assert_called()
    mock_logger.error.assert_not_called()


def test_process_payment_charge_returns_none(mock_gateway, mock_logger):
    order_id = ""order-789""
    amount = 75.0
    currency = ""EUR""
    mock_gateway.charge.return_value = None

    result = process_payment(
        order_id,
        amount,
        currency,
        payment_gateway=mock_gateway,
        logger=mock_logger,
    )

    assert result is False
    mock_gateway.charge.assert_called_once_with(order_id, amount, currency)
    mock_logger.info.assert_called()
    mock_logger.error.assert_not_called()


def test_process_payment_invalid_amount(mock_gateway, mock_logger):
    order_id = ""order-001""
    amount = -10.0
    currency = ""USD""

    with pytest.raises(ValueError):
        process_payment(
            order_id,
            amount,
            currency,
            payment_gateway=mock_gateway,
            logger=mock_logger,
        )

    mock_gateway.charge.assert_not_called()
    mock_logger.error.assert_called()


def test_process_payment_invalid_currency(mock_gateway, mock_logger):
    order_id = ""order-002""
    amount = 20.0
    currency = ""XYZ""  # Assuming unsupported

    with pytest.raises(ValueError):
        process_payment(
            order_id,
            amount,
            currency,
            payment_gateway=mock_gateway,
            logger=mock_logger,
        )

    mock_gateway.charge.assert_not_called()
    mock_logger.error.assert_called()


def test_process_payment_gateway_error_propagates(mock_gateway, mock_logger):
    order_id = ""order-003""
    amount = 100.0
    currency = ""USD""
    mock_gateway.charge.side_effect = GatewayError(""gateway failure"")

    with pytest.raises(GatewayError):
        process_payment(
            order_id,
            amount,
            currency,
            payment_gateway=mock_gateway,
            logger=mock_logger,
        )

    mock_gateway.charge.assert_called_once_with(order_id, amount, currency)
    mock_logger.error.assert_called()"
"def process_orders(
    orders: List[Dict[str, Any]],
    db: Database,
    payment_gateway: PaymentGateway,
    logger: Optional[Logger] = None,
) -> Tuple[int, List[int]]:
    """"""Processes a batch of e‑commerce orders.

    Args:
        orders: A list of dictionaries, each representing an order. Required keys are
            ``id`` (int) and ``amount`` (float). An optional ``discount`` (float) may be
            present and should be applied before charging.
        db: An instance of ``Database`` providing ``save_order(order: dict)`` and
            ``update_inventory(order_id: int)``. ``save_order`` may raise ``DatabaseError``.
        payment_gateway: Service used to charge payments. Exposes ``charge(order_id: int,
            amount: float) -> bool`` where ``True`` indicates success.
        logger: Optional ``Logger`` used for audit messages. If supplied, it must implement
            ``info(message: str)`` and ``error(message: str)``.

    Returns:
        A tuple ``(successful_count, failed_order_ids)`` where ``successful_count`` is the
        number of orders successfully saved and charged, and ``failed_order_ids`` is a list
        of order IDs for which the payment gateway returned ``False``.

    Raises:
        ValueError: If any order dict lacks the required ``id`` or ``amount`` keys.
        DatabaseError: Propagated if ``db.save_order`` fails for a particular order.
    """"""
    ...

# Dependencies
# - Database: methods ``save_order(order: dict)`` and ``update_inventory(order_id: int)``.
# - PaymentGateway: method ``charge(order_id: int, amount: float) -> bool``.
# - Logger (optional): methods ``info(message: str)`` and ``error(message: str)``.","import pytest
from unittest.mock import Mock, call

from typing import List, Dict, Any, Tuple, Optional

# Assume process_orders is imported from the module under test
# from mymodule import process_orders, DatabaseError

def test_process_orders_success():
    orders = [
        {""id"": 1, ""amount"": 100.0},
        {""id"": 2, ""amount"": 50.5},
    ]
    db = Mock()
    payment_gateway = Mock()
    payment_gateway.charge.side_effect = [True, True]
    logger = Mock()

    from mymodule import process_orders, DatabaseError

    result = process_orders(orders, db, payment_gateway, logger)

    assert result == (2, [])
    assert db.save_order.call_count == 2
    db.save_order.assert_has_calls([call(orders[0]), call(orders[1])])
    assert db.update_inventory.call_count == 2
    db.update_inventory.assert_has_calls([call(1), call(2)])
    assert payment_gateway.charge.call_count == 2
    payment_gateway.charge.assert_has_calls([call(1, 100.0), call(2, 50.5)])
    assert logger.info.call_count == 2
    logger.info.assert_has_calls([call(""Order 1 processed successfully""), call(""Order 2 processed successfully"")])
    logger.error.assert_not_called()


def test_process_orders_with_discount():
    orders = [
        {""id"": 3, ""amount"": 200.0, ""discount"": 20.0},
    ]
    db = Mock()
    payment_gateway = Mock()
    payment_gateway.charge.return_value = True
    logger = Mock()

    from mymodule import process_orders, DatabaseError

    result = process_orders(orders, db, payment_gateway, logger)

    assert result == (1, [])
    payment_gateway.charge.assert_called_once_with(3, 180.0)


def test_process_orders_missing_keys():
    orders = [
        {""amount"": 10.0},
        {""id"": 4},
    ]
    db = Mock()
    payment_gateway = Mock()
    logger = Mock()

    from mymodule import process_orders, DatabaseError

    with pytest.raises(ValueError):
        process_orders(orders, db, payment_gateway, logger)


def test_process_orders_db_error():
    orders = [
        {""id"": 5, ""amount"": 30.0},
    ]
    db = Mock()
    db.save_order.side_effect = Exception(""db error"")
    payment_gateway = Mock()
    logger = Mock()

    from mymodule import process_orders, DatabaseError

    with pytest.raises(Exception):
        process_orders(orders, db, payment_gateway, logger)

    db.save_order.assert_called_once_with(orders[0])
    payment_gateway.charge.assert_not_called()
    logger.error.assert_called_once()


def test_process_orders_payment_failure():
    orders = [
        {""id"": 6, ""amount"": 75.0},
        {""id"": 7, ""amount"": 40.0},
    ]
    db = Mock()
    payment_gateway = Mock()
    payment_gateway.charge.side_effect = [True, False]
    logger = Mock()

    from mymodule import process_orders, DatabaseError

    result = process_orders(orders, db, payment_gateway, logger)

    assert result == (1, [7])
    assert db.save_order.call_count == 2
    payment_gateway.charge.assert_has_calls([call(6, 75.0), call(7, 40.0)])
    logger.info.assert_called_once_with(""Order 6 processed successfully"")
    logger.error.assert_called_once_with(""Order 7 payment failed"")"
"class ImageProcessor:
    async def apply_filters(
        self,
        image_bytes: bytes,
        filter_sequence: List[str],
        filter_engine,
        storage_service,
        *,
        timeout: int = 30,
        logger: Optional[Logger] = None,
    ) -> str:
        """"""Applies a sequence of filters to an image and stores the result.

        Args:
            image_bytes: Raw image data in bytes.
            filter_sequence: Ordered list of filter names to apply (e.g., ``[""blur"", ""sharpen""]``).
                Each name must be supported by ``filter_engine``.
            filter_engine: Asynchronous service exposing ``apply(image: bytes, filter_name: str) -> bytes``.
                May raise ``FilterError`` if the filter cannot be applied.
            storage_service: Async client with ``store(data: bytes, path: str) -> str`` that returns the
                URI of the stored image. May raise ``StorageError``.
            timeout: Maximum time in seconds to wait for each filter operation; must be positive.
            logger (optional): ``logging.Logger`` for logging progress and errors.

        Returns:
            URI (string) of the stored processed image returned by ``storage_service.store``.

        Raises:
            ValueError: If ``filter_sequence`` is empty or contains unsupported filter names.
            FilterError: Propagated from ``filter_engine`` when a filter fails.
            StorageError: Propagated from ``storage_service`` when storing the image fails.
            asyncio.TimeoutError: If a filter operation exceeds the specified ``timeout``.

        Dependencies:
            - filter_engine: async ``apply`` method for individual filters.
            - storage_service: async ``store`` method for persisting processed images.
            - logger (optional): standard ``logging.Logger`` for audit logging.
        """"""

# Dependency details
# - filter_engine: async ``apply`` may raise ``FilterError``; must be awaited.
# - storage_service: async ``store`` may raise ``StorageError``; must be awaited.
# - logger (optional): ``info``/``error`` methods for logging.","import pytest
from unittest.mock import AsyncMock, MagicMock, ANY
import importlib
import asyncio

module = importlib.import_module(""image_processor"")
ImageProcessor = getattr(module, ""ImageProcessor"")
FilterError = getattr(module, ""FilterError"", Exception)
StorageError = getattr(module, ""StorageError"", Exception)


@pytest.fixture
def processor():
    return ImageProcessor()


@pytest.fixture
def mock_filter_engine():
    engine = MagicMock()
    engine.apply = AsyncMock()
    return engine


@pytest.fixture
def mock_storage_service():
    service = MagicMock()
    service.store = AsyncMock()
    return service


@pytest.fixture
def mock_logger():
    return MagicMock()


@pytest.mark.asyncio
async def test_apply_filters_success(
    processor,
    mock_filter_engine,
    mock_storage_service,
    mock_logger,
):
    image_bytes = b""original""
    filters = [""blur"", ""sharpen""]
    # Simulate sequential transform
    mock_filter_engine.apply.side_effect = [b""blurred"", b""sharpened""]
    mock_storage_service.store.return_value = ""s3://bucket/processed.jpg""

    result = await processor.apply_filters(
        image_bytes=image_bytes,
        filter_sequence=filters,
        filter_engine=mock_filter_engine,
        storage_service=mock_storage_service,
        timeout=30,
        logger=mock_logger,
    )

    assert result == ""s3://bucket/processed.jpg""
    # Verify apply called with correct order and data
    expected_calls = [
        ((image_bytes, ""blur""),),
        ((b""blurred"", ""sharpen""),),
    ]
    actual_calls = mock_filter_engine.apply.call_args_list
    assert len(actual_calls) == 2
    for actual, expected in zip(actual_calls, expected_calls):
        assert actual[0] == expected[0]
    mock_storage_service.store.assert_awaited_once_with(b""sharpened"", ANY)
    mock_logger.info.assert_called()


@pytest.mark.asyncio
async def test_apply_filters_empty_sequence(
    processor,
    mock_filter_engine,
    mock_storage_service,
    mock_logger,
):
    with pytest.raises(ValueError):
        await processor.apply_filters(
            image_bytes=b""data"",
            filter_sequence=[],
            filter_engine=mock_filter_engine,
            storage_service=mock_storage_service,
            logger=mock_logger,
        )
    mock_logger.error.assert_called()


@pytest.mark.asyncio
async def test_apply_filters_filter_error_propagates(
    processor,
    mock_filter_engine,
    mock_storage_service,
    mock_logger,
):
    mock_filter_engine.apply.side_effect = FilterError(""unsupported filter"")
    with pytest.raises(FilterError):
        await processor.apply_filters(
            image_bytes=b""data"",
            filter_sequence=[""unknown""],
            filter_engine=mock_filter_engine,
            storage_service=mock_storage_service,
            logger=mock_logger,
        )
    mock_logger.error.assert_called()


@pytest.mark.asyncio
async def test_apply_filters_storage_error_propagates(
    processor,
    mock_filter_engine,
    mock_storage_service,
    mock_logger,
):
    mock_filter_engine.apply.return_value = b""processed""
    mock_storage_service.store.side_effect = StorageError(""save failed"")
    with pytest.raises(StorageError):
        await processor.apply_filters(
            image_bytes=b""data"",
            filter_sequence=[""blur""],
            filter_engine=mock_filter_engine,
            storage_service=mock_storage_service,
            logger=mock_logger,
        )
    mock_logger.error.assert_called()


@pytest.mark.asyncio
async def test_apply_filters_timeout_error(
    processor,
    mock_filter_engine,
    mock_storage_service,
    mock_logger,
):
    async def slow_apply(*args, **kwargs):
        await asyncio.sleep(0.1)
        raise asyncio.TimeoutError

    mock_filter_engine.apply.side_effect = slow_apply
    with pytest.raises(asyncio.TimeoutError):
        await processor.apply_filters(
            image_bytes=b""data"",
            filter_sequence=[""blur""],
            filter_engine=mock_filter_engine,
            storage_service=mock_storage_service,
            timeout=0.01,
            logger=mock_logger,
        )
    mock_logger.error.assert_called()"
"class DataPipeline:
    def run_stage(
        self,
        stage_name: str,
        input_data: Any,
        storage_backend,
        transformer,
        validator,
        *,
        config,
        metrics_collector,
        error_handler=None,
    ) -> Any:
        """"""Executes a single stage of a data processing pipeline.

        Args:
            stage_name: Identifier for the pipeline stage; must correspond to a known
                configuration entry.
            input_data: The raw data to be processed by this stage.
            storage_backend: Object exposing ``read(key: str) -> Any`` and ``write(key: str,
                data: Any) -> None``. May raise ``StorageError``.
            transformer: Callable ``transform(data: Any, params: dict) -> Any`` that
                applies business logic. ``params`` are retrieved from ``config`` based on
                ``stage_name``.
            validator: Callable ``validate(data: Any) -> None``; raises ``ValidationError``
                if the data does not conform to the schema.
            config: Configuration mapping providing per‑stage settings such as
                ``TRANSFORM_PARAMS`` (dict), ``OUTPUT_KEY`` (str), and ``RETRY_COUNT``
                (int). Missing keys should raise ``ConfigError``.
            metrics_collector: Service with methods ``increment(metric_name: str, tags:
                Optional[dict] = None)`` and ``record_timing(metric_name: str,
                duration_seconds: float, tags: Optional[dict] = None)``.
            error_handler: Optional callable ``handle(error: Exception, stage: str) -> Any``
                that returns a fallback value; if omitted, the error is re‑raised.

        Returns:
            The transformed and validated data, optionally written to the configured
            output location in ``storage_backend``. If ``config.OUTPUT_KEY`` is set,
            the result is also stored under that key.

        Raises:
            ConfigError: If required configuration for ``stage_name`` is missing or malformed.
            StorageError: Propagated from ``storage_backend`` read/write operations.
            ValidationError: If ``validator`` raises an exception.
            TransformError: If ``transformer`` raises an exception.
            RuntimeError: For any unexpected condition not covered by the above.

        Dependencies:
            - storage_backend: ``read`` and ``write`` methods.
            - transformer: Callable ``transform`` with stage‑specific parameters.
            - validator: Callable ``validate``.
            - config: Mapping containing per‑stage settings.
            - metrics_collector: Methods ``increment`` and ``record_timing``.
            - error_handler (optional): Callable for custom error recovery.
        """"""
        ...

# Dependency details
# - storage_backend: read/write may raise StorageError.
# - transformer: may raise TransformError.
# - validator: may raise ValidationError.
# - config: must provide TRANSFORM_PARAMS, OUTPUT_KEY, RETRY_COUNT per stage.
# - metrics_collector: used for counting successes/failures and timing.
# - error_handler: optional custom fallback logic.","import pytest
from unittest.mock import MagicMock, call
import importlib

module = importlib.import_module(""data_pipeline_module"")
DataPipeline = getattr(module, ""DataPipeline"")
ConfigError = getattr(module, ""ConfigError"", Exception)
StorageError = getattr(module, ""StorageError"", Exception)
ValidationError = getattr(module, ""ValidationError"", Exception)
TransformError = getattr(module, ""TransformError"", Exception)


@pytest.fixture
def pipeline():
    return DataPipeline()


@pytest.fixture
def storage_backend():
    return MagicMock()


@pytest.fixture
def transformer():
    return MagicMock()


@pytest.fixture
def validator():
    return MagicMock()


@pytest.fixture
def metrics_collector():
    return MagicMock()


def test_run_stage_success(
    pipeline,
    storage_backend,
    transformer,
    validator,
    metrics_collector,
):
    stage = ""stage1""
    config = {
        stage: {
            ""TRANSFORM_PARAMS"": {""factor"": 3},
            ""OUTPUT_KEY"": ""output_key"",
            ""RETRY_COUNT"": 0,
        }
    }

    transformer.side_effect = lambda data, params: data * params[""factor""]
    validator.return_value = None  # passes validation

    input_data = 5
    result = pipeline.run_stage(
        stage_name=stage,
        input_data=input_data,
        storage_backend=storage_backend,
        transformer=transformer,
        validator=validator,
        config=config,
        metrics_collector=metrics_collector,
    )

    assert result == 15
    transformer.assert_called_once_with(input_data, {""factor"": 3})
    validator.assert_called_once_with(15)
    storage_backend.write.assert_called_once_with(""output_key"", 15)
    assert metrics_collector.increment.called
    assert metrics_collector.record_timing.called


def test_run_stage_missing_config_raises_config_error(
    pipeline,
    storage_backend,
    transformer,
    validator,
    metrics_collector,
):
    stage = ""missing_stage""
    config = {}  # no entry for the stage

    with pytest.raises(ConfigError):
        pipeline.run_stage(
            stage_name=stage,
            input_data=""data"",
            storage_backend=storage_backend,
            transformer=transformer,
            validator=validator,
            config=config,
            metrics_collector=metrics_collector,
        )

    transformer.assert_not_called()
    validator.assert_not_called()
    storage_backend.write.assert_not_called()
    metrics_collector.increment.assert_not_called()
    metrics_collector.record_timing.assert_not_called()


def test_run_stage_validator_error_propagates(
    pipeline,
    storage_backend,
    transformer,
    validator,
    metrics_collector,
):
    stage = ""stage2""
    config = {
        stage: {
            ""TRANSFORM_PARAMS"": {},
            ""OUTPUT_KEY"": ""out"",
            ""RETRY_COUNT"": 0,
        }
    }

    transformer.side_effect = lambda data, params: data
    validator.side_effect = ValidationError(""invalid"")

    with pytest.raises(ValidationError):
        pipeline.run_stage(
            stage_name=stage,
            input_data=""bad_data"",
            storage_backend=storage_backend,
            transformer=transformer,
            validator=validator,
            config=config,
            metrics_collector=metrics_collector,
        )

    transformer.assert_called_once()
    validator.assert_called_once()
    storage_backend.write.assert_not_called()
    assert metrics_collector.increment.called
    assert metrics_collector.record_timing.called


def test_run_stage_transform_error_with_error_handler(
    pipeline,
    storage_backend,
    transformer,
    validator,
    metrics_collector,
):
    stage = ""stage3""
    config = {
        stage: {
            ""TRANSFORM_PARAMS"": {},
            ""OUTPUT_KEY"": ""out_key"",
            ""RETRY_COUNT"": 0,
        }
    }

    transformer.side_effect = TransformError(""transform failure"")
    validator.return_value = None
    error_handler = MagicMock(return_value=""fallback_value"")

    result = pipeline.run_stage(
        stage_name=stage,
        input_data=""data"",
        storage_backend=storage_backend,
        transformer=transformer,
        validator=validator,
        config=config,
        metrics_collector=metrics_collector,
        error_handler=error_handler,
    )

    assert result == ""fallback_value""
    transformer.assert_called_once()
    error_handler.assert_called_once()
    # when error handler supplies fallback, no write should occur
    storage_backend.write.assert_not_called()
    assert metrics_collector.increment.called
    assert metrics_collector.record_timing.called


def test_run_stage_storage_error_propagates_if_no_retry(
    pipeline,
    storage_backend,
    transformer,
    validator,
    metrics_collector,
):
    stage = ""stage4""
    config = {
        stage: {
            ""TRANSFORM_PARAMS"": {},
            ""OUTPUT_KEY"": ""out_key"",
            ""RETRY_COUNT"": 0,
        }
    }

    transformer.side_effect = lambda d, p: d
    validator.return_value = None
    storage_backend.write.side_effect = StorageError(""write failed"")

    with pytest.raises(StorageError):
        pipeline.run_stage(
            stage_name=stage,
            input_data=""data"",
            storage_backend=storage_backend,
            transformer=transformer,
            validator=validator,
            config=config,
            metrics_collector=metrics_collector,
        )

    transformer.assert_called_once()
    validator.assert_called_once()
    storage_backend.write.assert_called_once()
    assert metrics_collector.increment.called
    assert metrics_collector.record_timing.called"
"class OrderProcessor:
    def process_order(
        self,
        order: dict,
        payment_gateway,
        inventory_service,
        notification_service=None,
        logger=None,
    ) -> bool:
        """"""Processes an e‑commerce order, handling payment, inventory reservation, and optional notification.

        Args:
            order: Dictionary representing the order with keys ``order_id`` (int), ``items`` (list of dicts with
                ``product_id`` and ``quantity``), and ``total_amount`` (float).
            payment_gateway: Service exposing ``charge(order_id: int, amount: float) -> bool``.
                May raise ``PaymentError`` on failure.
            inventory_service: Service with ``reserve_items(order_id: int, items: List[dict]) -> None``.
                May raise ``InventoryError`` if stock is insufficient.
            notification_service: Optional service providing ``send_confirmation(order_id: int) -> None``.
                May raise ``NotificationError``.
            logger: Optional ``logging.Logger`` used to log each processing step and any errors.

        Returns:
            ``True`` if the order was processed successfully; ``False`` otherwise.

        Raises:
            ValueError: If required order fields are missing or malformed.
            PaymentError: Propagated from ``payment_gateway`` when charging fails.
            InventoryError: Propagated from ``inventory_service`` when reservation fails.
            NotificationError: Propagated from ``notification_service`` if sending the confirmation fails.

        Dependencies:
            - payment_gateway: Provides ``charge`` for payment processing.
            - inventory_service: Provides ``reserve_items`` for inventory management.
            - notification_service (optional): Provides ``send_confirmation`` for user notifications.
            - logger (optional): ``logging.Logger`` for audit trails.
        """"""
        ...

# Dependency details
# - payment_gateway: ``charge(order_id: int, amount: float) -> bool``; may raise ``PaymentError``.
# - inventory_service: ``reserve_items(order_id: int, items: List[dict]) -> None``; may raise ``InventoryError``.
# - notification_service (optional): ``send_confirmation(order_id: int) -> None``; may raise ``NotificationError``.
# - logger (optional): ``logging.Logger`` instance.","import pytest
from unittest.mock import MagicMock, call, patch
import importlib

module = importlib.import_module(""order_processor"")
OrderProcessor = getattr(module, ""OrderProcessor"")
PaymentError = getattr(module, ""PaymentError"", Exception)
InventoryError = getattr(module, ""InventoryError"", Exception)
NotificationError = getattr(module, ""NotificationError"", Exception)


@pytest.fixture
def processor():
    return OrderProcessor()


def test_process_order_success_with_all_dependencies(processor):
    order = {""order_id"": 101, ""items"": [{""product_id"": 1, ""quantity"": 2}], ""total_amount"": 59.99}
    payment_gateway = MagicMock()
    payment_gateway.charge.return_value = True
    inventory_service = MagicMock()
    notification_service = MagicMock()
    logger = MagicMock()

    result = processor.process_order(
        order,
        payment_gateway,
        inventory_service,
        notification_service=notification_service,
        logger=logger,
    )

    assert result is True
    payment_gateway.charge.assert_called_once_with(order[""order_id""], order[""total_amount""])
    inventory_service.reserve_items.assert_called_once_with(order[""order_id""], order[""items""])
    notification_service.send_confirmation.assert_called_once_with(order[""order_id""])
    logger.info.assert_called()


def test_process_order_success_without_optional_dependencies(processor):
    order = {""order_id"": 202, ""items"": [{""product_id"": 2, ""quantity"": 1}], ""total_amount"": 15.0}
    payment_gateway = MagicMock()
    payment_gateway.charge.return_value = True
    inventory_service = MagicMock()

    result = processor.process_order(order, payment_gateway, inventory_service)

    assert result is True
    payment_gateway.charge.assert_called_once_with(order[""order_id""], order[""total_amount""])
    inventory_service.reserve_items.assert_called_once_with(order[""order_id""], order[""items""])


def test_process_order_missing_fields_raises_value_error(processor):
    incomplete_order = {""order_id"": 303, ""items"": []}  # missing total_amount
    payment_gateway = MagicMock()
    inventory_service = MagicMock()

    with pytest.raises(ValueError):
        processor.process_order(incomplete_order, payment_gateway, inventory_service)


def test_process_order_payment_failure_raises_payment_error(processor):
    order = {""order_id"": 404, ""items"": [{""product_id"": 3, ""quantity"": 5}], ""total_amount"": 200.0}
    payment_gateway = MagicMock()
    payment_gateway.charge.side_effect = PaymentError(""declined"")
    inventory_service = MagicMock()

    with pytest.raises(PaymentError):
        processor.process_order(order, payment_gateway, inventory_service)


def test_process_order_payment_declined_returns_false(processor):
    order = {""order_id"": 505, ""items"": [{""product_id"": 4, ""quantity"": 1}], ""total_amount"": 30.0}
    payment_gateway = MagicMock()
    payment_gateway.charge.return_value = False
    inventory_service = MagicMock()

    result = processor.process_order(order, payment_gateway, inventory_service)

    assert result is False
    payment_gateway.charge.assert_called_once_with(order[""order_id""], order[""total_amount""])
    inventory_service.reserve_items.assert_not_called()


def test_process_order_inventory_error_propagates(processor):
    order = {""order_id"": 606, ""items"": [{""product_id"": 5, ""quantity"": 3}], ""total_amount"": 75.0}
    payment_gateway = MagicMock()
    payment_gateway.charge.return_value = True
    inventory_service = MagicMock()
    inventory_service.reserve_items.side_effect = InventoryError(""out of stock"")

    with pytest.raises(InventoryError):
        processor.process_order(order, payment_gateway, inventory_service)


def test_process_order_notification_error_propagates(processor):
    order = {""order_id"": 707, ""items"": [{""product_id"": 6, ""quantity"": 2}], ""total_amount"": 120.0}
    payment_gateway = MagicMock()
    payment_gateway.charge.return_value = True
    inventory_service = MagicMock()
    notification_service = MagicMock()
    notification_service.send_confirmation.side_effect = NotificationError(""email failure"")
    logger = MagicMock()

    with pytest.raises(NotificationError):
        processor.process_order(
            order,
            payment_gateway,
            inventory_service,
            notification_service=notification_service,
            logger=logger,
        )

    payment_gateway.charge.assert_called_once_with(order[""order_id""], order[""total_amount""])
    inventory_service.reserve_items.assert_called_once_with(order[""order_id""], order[""items""])
    notification_service.send_confirmation.assert_called_once_with(order[""order_id""])
    logger.error.assert_called()"
"def calculate_discount(price: float, user_tier: str, discount_service) -> float:
    """"""Calculates the discount amount for a given price based on user tier.

    Args:
        price: The original price of the item. Must be a non‑negative float.
        user_tier: Tier of the user, e.g., ``""standard""``, ``""gold""``, ``""platinum""``.
        discount_service: Service with method ``get_rate(tier: str) -> float`` returning the discount
            rate as a fraction (e.g., ``0.15`` for 15%). May raise ``TierNotFoundError`` if the tier is unknown.

    Returns:
        The discount amount to subtract from the original price.

    Raises:
        ValueError: If ``price`` is negative or ``user_tier`` is empty.
        TierNotFoundError: Propagated when ``discount_service.get_rate`` does not recognize the tier.

    Dependencies:
        - discount_service: provides ``get_rate`` to fetch discount percentages.
    """"""
    pass","import pytest
from unittest.mock import MagicMock
import importlib

module = importlib.import_module(""target_module"")
calculate_discount = getattr(module, ""calculate_discount"")
TierNotFoundError = getattr(module, ""TierNotFoundError"", Exception)


@pytest.fixture
def discount_service():
    return MagicMock()


def test_calculate_discount_happy_path(discount_service):
    price = 100.0
    tier = ""gold""
    discount_service.get_rate.return_value = 0.2

    result = calculate_discount(price, tier, discount_service)

    assert result == pytest.approx(20.0)
    discount_service.get_rate.assert_called_once_with(tier)


def test_calculate_discount_zero_price(discount_service):
    price = 0.0
    tier = ""standard""
    discount_service.get_rate.return_value = 0.15

    result = calculate_discount(price, tier, discount_service)

    assert result == pytest.approx(0.0)
    discount_service.get_rate.assert_called_once_with(tier)


def test_calculate_discount_negative_price_raises(discount_service):
    price = -10.0
    tier = ""platinum""
    with pytest.raises(ValueError):
        calculate_discount(price, tier, discount_service)
    discount_service.get_rate.assert_not_called()


def test_calculate_discount_empty_tier_raises(discount_service):
    price = 50.0
    tier = """"
    with pytest.raises(ValueError):
        calculate_discount(price, tier, discount_service)
    discount_service.get_rate.assert_not_called()


def test_calculate_discount_tier_not_found_propagates(discount_service):
    price = 75.0
    tier = ""unknown""
    discount_service.get_rate.side_effect = TierNotFoundError(""Tier not found"")
    with pytest.raises(TierNotFoundError):
        calculate_discount(price, tier, discount_service)
    discount_service.get_rate.assert_called_once_with(tier)"
"class EmailSender:
    def send_email(
        self,
        recipient: str,
        subject: str,
        body: str,
        smtp_client,
        logger,
        *,
        cc: list = None,
    ) -> bool:
        """"""Sends an email via SMTP.

        Args:
            recipient: Email address of the primary recipient.
            subject: Subject line of the email.
            body: Plain‑text body of the email.
            smtp_client: Object exposing ``send(to: str, subject: str, body: str, cc: list) -> None`` and may raise ``SMTPError``.
            logger: Logger with ``info(message: str)`` and ``error(message: str)`` methods.
            cc: Optional list of CC addresses.

        Returns:
            ``True`` if the email was sent without raising an exception.

        Raises:
            ValueError: If ``recipient`` or ``subject`` is empty.
            SMTPError: Propagated from ``smtp_client.send`` when sending fails.

        Dependencies:
            - smtp_client: ``send(to, subject, body, cc)`` method.
            - logger: ``info`` and ``error`` methods.
        """"""","import pytest
from unittest.mock import MagicMock

from email_module import EmailSender, SMTPError


@pytest.fixture
def sender():
    return EmailSender()


@pytest.fixture
def smtp_client():
    return MagicMock()


@pytest.fixture
def logger():
    return MagicMock()


def test_send_email_happy_path(sender, smtp_client, logger):
    smtp_client.send.return_value = None
    result = sender.send_email(
        recipient=""user@example.com"",
        subject=""Test Subject"",
        body=""Test Body"",
        smtp_client=smtp_client,
        logger=logger,
    )
    assert result is True
    smtp_client.send.assert_called_once_with(
        ""user@example.com"", ""Test Subject"", ""Test Body"", None
    )
    logger.info.assert_called()


def test_send_email_with_cc(sender, smtp_client, logger):
    cc_list = [""cc1@example.com"", ""cc2@example.com""]
    smtp_client.send.return_value = None
    result = sender.send_email(
        recipient=""user@example.com"",
        subject=""Subject"",
        body=""Body"",
        smtp_client=smtp_client,
        logger=logger,
        cc=cc_list,
    )
    assert result is True
    smtp_client.send.assert_called_once_with(
        ""user@example.com"", ""Subject"", ""Body"", cc_list
    )
    logger.info.assert_called()


def test_send_email_empty_recipient(sender, smtp_client, logger):
    with pytest.raises(ValueError):
        sender.send_email(
            recipient="""",
            subject=""Subject"",
            body=""Body"",
            smtp_client=smtp_client,
            logger=logger,
        )
    smtp_client.send.assert_not_called()
    logger.error.assert_called()


def test_send_email_empty_subject(sender, smtp_client, logger):
    with pytest.raises(ValueError):
        sender.send_email(
            recipient=""user@example.com"",
            subject="""",
            body=""Body"",
            smtp_client=smtp_client,
            logger=logger,
        )
    smtp_client.send.assert_not_called()
    logger.error.assert_called()


def test_send_email_smtp_error(sender, smtp_client, logger):
    smtp_client.send.side_effect = SMTPError(""sending failed"")
    with pytest.raises(SMTPError):
        sender.send_email(
            recipient=""user@example.com"",
            subject=""Subject"",
            body=""Body"",
            smtp_client=smtp_client,
            logger=logger,
        )
    smtp_client.send.assert_called_once()
    logger.error.assert_called()"
"class FileUploader:
    async def upload_files(
        self,
        file_paths: List[str],
        destination_folder: str,
        storage_client,
        auth_service,
        *,
        overwrite: bool = False,
        logger=None,
    ) -> Dict[str, bool]:
        """"""Uploads multiple local files to a remote storage bucket.

        Args:
            file_paths: List of absolute file system paths to be uploaded.
            destination_folder: Target folder path in the remote storage where files will be placed.
            storage_client: Client exposing ``async upload(file_path: str, remote_path: str) -> None``.
                May raise ``StorageError`` on failure.
            auth_service: Service providing ``get_token() -> str`` used for authentication with the storage client.
                May raise ``AuthError`` if credentials are invalid.
            overwrite: If ``True`` existing remote files with the same name will be overwritten.
                Defaults to ``False``.
            logger: Optional ``logging.Logger`` used to log upload attempts and outcomes.

        Returns:
            Mapping from original ``file_path`` to a boolean indicating success (``True``) or failure (``False``).

        Raises:
            ValueError: If ``file_paths`` is empty or any path does not exist.
            AuthError: Propagated from ``auth_service`` when authentication fails.
            StorageError: Propagated from ``storage_client`` for upload failures that are not recoverable.

        Dependencies:
            - storage_client: Provides asynchronous ``upload`` method.
            - auth_service: Provides ``get_token`` for authentication.
            - logger (optional): ``logging.Logger`` instance for audit logging.
        """"""","import pytest
from unittest.mock import AsyncMock, MagicMock, patch, call

import importlib

module = importlib.import_module(""file_uploader_module"")
FileUploader = getattr(module, ""FileUploader"")
AuthError = getattr(module, ""AuthError"", Exception)
StorageError = getattr(module, ""StorageError"", Exception)


@pytest.fixture
def uploader():
    return FileUploader()


@pytest.fixture
def mock_storage_client():
    client = MagicMock()
    client.upload = AsyncMock()
    return client


@pytest.fixture
def mock_auth_service():
    service = MagicMock()
    service.get_token = MagicMock(return_value=""valid-token"")
    return service


@pytest.fixture
def mock_logger():
    return MagicMock()


@pytest.mark.asyncio
async def test_upload_files_success(
    uploader,
    mock_storage_client,
    mock_auth_service,
    mock_logger,
):
    file_paths = [""/tmp/file1.txt"", ""/tmp/file2.txt""]
    destination = ""remote/folder""

    with patch(""os.path.isfile"", return_value=True):
        result = await uploader.upload_files(
            file_paths=file_paths,
            destination_folder=destination,
            storage_client=mock_storage_client,
            auth_service=mock_auth_service,
            overwrite=False,
            logger=mock_logger,
        )

    expected = {p: True for p in file_paths}
    assert result == expected

    mock_auth_service.get_token.assert_called_once()
    calls = [
        call(p, f""{destination}/{p.split('/')[-1]}"")
        for p in file_paths
    ]
    mock_storage_client.upload.assert_awaited()
    mock_storage_client.upload.assert_has_awaits(calls, any_order=False)
    mock_logger.info.assert_called()


@pytest.mark.asyncio
async def test_upload_files_empty_paths(
    uploader,
    mock_storage_client,
    mock_auth_service,
    mock_logger,
):
    with pytest.raises(ValueError):
        await uploader.upload_files(
            file_paths=[],
            destination_folder=""dest"",
            storage_client=mock_storage_client,
            auth_service=mock_auth_service,
            logger=mock_logger,
        )
    mock_logger.error.assert_called()


@pytest.mark.asyncio
async def test_upload_files_missing_file(
    uploader,
    mock_storage_client,
    mock_auth_service,
    mock_logger,
):
    file_paths = [""/tmp/exists.txt"", ""/tmp/missing.txt""]
    destination = ""remote""

    def isfile(path):
        return path != ""/tmp/missing.txt""

    with patch(""os.path.isfile"", side_effect=isfile):
        with pytest.raises(ValueError):
            await uploader.upload_files(
                file_paths=file_paths,
                destination_folder=destination,
                storage_client=mock_storage_client,
                auth_service=mock_auth_service,
                logger=mock_logger,
            )
    mock_logger.error.assert_called()


@pytest.mark.asyncio
async def test_upload_files_auth_error(
    uploader,
    mock_storage_client,
    mock_logger,
):
    file_paths = [""/tmp/file.txt""]
    destination = ""remote""

    auth_service = MagicMock()
    auth_service.get_token.side_effect = AuthError(""invalid credentials"")

    with patch(""os.path.isfile"", return_value=True):
        with pytest.raises(AuthError):
            await uploader.upload_files(
                file_paths=file_paths,
                destination_folder=destination,
                storage_client=mock_storage_client,
                auth_service=auth_service,
                logger=mock_logger,
            )
    auth_service.get_token.assert_called_once()
    mock_logger.error.assert_called()


@pytest.mark.asyncio
async def test_upload_files_storage_error(
    uploader,
    mock_auth_service,
    mock_logger,
):
    file_paths = [""/tmp/file.txt""]
    destination = ""remote""

    storage_client = MagicMock()
    storage_client.upload = AsyncMock(side_effect=StorageError(""upload failed""))

    with patch(""os.path.isfile"", return_value=True):
        with pytest.raises(StorageError):
            await uploader.upload_files(
                file_paths=file_paths,
                destination_folder=destination,
                storage_client=storage_client,
                auth_service=mock_auth_service,
                logger=mock_logger,
            )
    mock_auth_service.get_token.assert_called_once()
    storage_client.upload.assert_awaited_once()
    mock_logger.error.assert_called()"
"def process_payment(
    order_id: str,
    amount: Decimal,
    currency: str,
    payment_gateway,
    fraud_service,
    notifier=None,
    logger: Optional[logging.Logger] = None,
) -> str:
    """"""Processes a payment for a given order using an external payment gateway.

    Args:
        order_id: Unique identifier of the order to be paid.
        amount: Monetary amount to be charged. Must be a positive ``Decimal``.
        currency: ISO‑4217 currency code (e.g., ``""USD""``, ``""EUR""``).
        payment_gateway: Object exposing ``charge(order_id: str, amount: Decimal, currency: str) -> str``
            which returns a transaction ID. May raise ``PaymentError`` on failure.
        fraud_service: Service with ``check(order_id: str, amount: Decimal) -> bool`` returning ``True``
            if the transaction passes fraud checks; otherwise raises ``FraudDetected``.
        notifier (optional): Callable ``notify(user_id: str, message: str) -> None`` used to send
            confirmation messages. May raise ``NotificationError``.
        logger (optional): Logger implementing ``info(message: str)`` and ``error(message: str)`` for audit trails.

    Returns:
        The transaction ID string returned by ``payment_gateway.charge``.

    Raises:
        ValueError: If ``amount`` is not positive or ``currency`` is not a three‑letter code.
        FraudDetected: Propagated if ``fraud_service.check`` flags the transaction.
        PaymentError: Propagated when ``payment_gateway.charge`` fails.
        NotificationError: Propagated if ``notifier`` is provided and fails.

    Dependencies:
        - payment_gateway: method ``charge(order_id: str, amount: Decimal, currency: str) -> str`` may raise ``PaymentError``.
        - fraud_service: method ``check(order_id: str, amount: Decimal) -> bool`` may raise ``FraudDetected``.
        - notifier (optional): callable ``notify(user_id: str, message: str) -> None`` may raise ``NotificationError``.
        - logger (optional): methods ``info`` and ``error`` for logging.
    """"""
    ...

# Dependency specifications
# - payment_gateway: ``charge`` returns transaction ID; raises ``PaymentError``.
# - fraud_service: ``check`` returns bool; raises ``FraudDetected``.
# - notifier (optional): ``notify`` may raise ``NotificationError``.
# - logger (optional): ``info`` / ``error`` methods.","import pytest
from unittest.mock import MagicMock, call
import importlib
from decimal import Decimal
import logging

module = importlib.import_module(""payment_module"")
process_payment = getattr(module, ""process_payment"")
PaymentError = getattr(module, ""PaymentError"", Exception)
FraudDetected = getattr(module, ""FraudDetected"", Exception)
NotificationError = getattr(module, ""NotificationError"", Exception)


@pytest.fixture
def order_id():
    return ""order-123""


@pytest.fixture
def amount():
    return Decimal(""99.99"")


@pytest.fixture
def currency():
    return ""USD""


@pytest.fixture
def transaction_id():
    return ""txn-456""


@pytest.fixture
def payment_gateway(transaction_id):
    gateway = MagicMock()
    gateway.charge.return_value = transaction_id
    return gateway


@pytest.fixture
def fraud_service():
    service = MagicMock()
    service.check.return_value = True
    return service


@pytest.fixture
def notifier():
    return MagicMock()


@pytest.fixture
def logger():
    return MagicMock(spec=logging.Logger)


def test_process_payment_happy_path(
    order_id,
    amount,
    currency,
    payment_gateway,
    fraud_service,
    notifier,
    logger,
    transaction_id,
):
    result = process_payment(
        order_id=order_id,
        amount=amount,
        currency=currency,
        payment_gateway=payment_gateway,
        fraud_service=fraud_service,
        notifier=notifier,
        logger=logger,
    )
    assert result == transaction_id
    fraud_service.check.assert_called_once_with(order_id, amount)
    payment_gateway.charge.assert_called_once_with(order_id, amount, currency)
    notifier.notify.assert_called_once()
    logger.info.assert_called()


def test_process_payment_without_notifier(
    order_id,
    amount,
    currency,
    payment_gateway,
    fraud_service,
    logger,
    transaction_id,
):
    result = process_payment(
        order_id=order_id,
        amount=amount,
        currency=currency,
        payment_gateway=payment_gateway,
        fraud_service=fraud_service,
        notifier=None,
        logger=logger,
    )
    assert result == transaction_id
    fraud_service.check.assert_called_once_with(order_id, amount)
    payment_gateway.charge.assert_called_once_with(order_id, amount, currency)
    logger.info.assert_called()


def test_process_payment_invalid_amount(
    order_id,
    currency,
    payment_gateway,
    fraud_service,
    notifier,
    logger,
):
    with pytest.raises(ValueError):
        process_payment(
            order_id=order_id,
            amount=Decimal(""-10""),
            currency=currency,
            payment_gateway=payment_gateway,
            fraud_service=fraud_service,
            notifier=notifier,
            logger=logger,
        )
    fraud_service.check.assert_not_called()
    payment_gateway.charge.assert_not_called()
    if notifier:
        notifier.notify.assert_not_called()
    logger.error.assert_called()


def test_process_payment_invalid_currency(
    order_id,
    amount,
    payment_gateway,
    fraud_service,
    notifier,
    logger,
):
    with pytest.raises(ValueError):
        process_payment(
            order_id=order_id,
            amount=amount,
            currency=""US"",  # not three letters
            payment_gateway=payment_gateway,
            fraud_service=fraud_service,
            notifier=notifier,
            logger=logger,
        )
    fraud_service.check.assert_not_called()
    payment_gateway.charge.assert_not_called()
    if notifier:
        notifier.notify.assert_not_called()
    logger.error.assert_called()


def test_process_payment_fraud_detected(
    order_id,
    amount,
    currency,
    payment_gateway,
    fraud_service,
    notifier,
    logger,
):
    fraud_service.check.side_effect = FraudDetected()
    with pytest.raises(FraudDetected):
        process_payment(
            order_id=order_id,
            amount=amount,
            currency=currency,
            payment_gateway=payment_gateway,
            fraud_service=fraud_service,
            notifier=notifier,
            logger=logger,
        )
    fraud_service.check.assert_called_once_with(order_id, amount)
    payment_gateway.charge.assert_not_called()
    if notifier:
        notifier.notify.assert_not_called()
    logger.error.assert_called()


def test_process_payment_payment_error(
    order_id,
    amount,
    currency,
    payment_gateway,
    fraud_service,
    notifier,
    logger,
):
    payment_gateway.charge.side_effect = PaymentError()
    result = None
    with pytest.raises(PaymentError):
        process_payment(
            order_id=order_id,
            amount=amount,
            currency=currency,
            payment_gateway=payment_gateway,
            fraud_service=fraud_service,
            notifier=notifier,
            logger=logger,
        )
    fraud_service.check.assert_called_once_with(order_id, amount)
    payment_gateway.charge.assert_called_once_with(order_id, amount, currency)
    if notifier:
        notifier.notify.assert_not_called()
    logger.error.assert_called()


def test_process_payment_notifier_error(
    order_id,
    amount,
    currency,
    payment_gateway,
    fraud_service,
    notifier,
    logger,
    transaction_id,
):
    notifier.notify.side_effect = NotificationError()
    with pytest.raises(NotificationError):
        process_payment(
            order_id=order_id,
            amount=amount,
            currency=currency,
            payment_gateway=payment_gateway,
            fraud_service=fraud_service,
            notifier=notifier,
            logger=logger,
        )
    fraud_service.check.assert_called_once_with(order_id, amount)
    payment_gateway.charge.assert_called_once_with(order_id, amount, currency)
    notifier.notify.assert_called_once()
    logger.error.assert_called()"
"async def get_weather_forecast(
    location: str,
    date: datetime.date,
    api_client,
    cache_client=None,
) -> dict:
    """"""Fetches weather forecast data for a specific location and date, with optional caching.

    Args:
        location: Human‑readable location name or coordinates.
        date: Target date for the forecast; must be today or a future date.
        api_client: Service exposing ``fetch_forecast(location: str, date: str) -> dict``.
            May raise ``ApiError`` on network or service failures.
        cache_client (optional): Cache abstraction with ``get(key: str) -> dict`` and ``set(key: str, value: dict, ttl: int)``.
            ``get`` returns ``None`` if the entry is missing; may raise ``CacheError``.

    Returns:
        Dictionary containing forecast details as returned by ``api_client``.

    Raises:
        ValueError: If ``date`` is in the past.
        ApiError: Propagated from ``api_client`` when the remote request fails.
        CacheError: Propagated from ``cache_client`` on cache operation failures.

    Dependencies:
        - api_client: Provides ``fetch_forecast`` for retrieving weather data.
        - cache_client (optional): Provides ``get`` and ``set`` for caching forecast results.
    """"""
    ...

# Dependency specifications
# - api_client: ``fetch_forecast(location: str, date: str) -> dict``; may raise ``ApiError``.
# - cache_client (optional): ``get(key: str) -> dict`` and ``set(key: str, value: dict, ttl: int)``; may raise ``CacheError``.","import pytest
from unittest.mock import AsyncMock, MagicMock, ANY
import datetime

from weather_module import get_weather_forecast, ApiError, CacheError


@pytest.fixture
def api_client():
    client = MagicMock()
    client.fetch_forecast = AsyncMock()
    return client


@pytest.fixture
def cache_client():
    client = MagicMock()
    client.get = MagicMock()
    client.set = MagicMock()
    return client


@pytest.mark.asyncio
async def test_get_weather_forecast_cache_miss(api_client, cache_client):
    forecast = {""temp"": 20}
    api_client.fetch_forecast.return_value = forecast
    cache_client.get.return_value = None

    result = await get_weather_forecast(
        location=""London"",
        date=datetime.date.today(),
        api_client=api_client,
        cache_client=cache_client,
    )

    assert result == forecast
    cache_client.get.assert_called_once()
    api_client.fetch_forecast.assert_awaited_once()
    cache_client.set.assert_called_once_with(ANY, forecast, ANY)


@pytest.mark.asyncio
async def test_get_weather_forecast_cache_hit(api_client, cache_client):
    forecast = {""temp"": 15}
    cache_client.get.return_value = forecast

    result = await get_weather_forecast(
        location=""Paris"",
        date=datetime.date.today(),
        api_client=api_client,
        cache_client=cache_client,
    )

    assert result == forecast
    cache_client.get.assert_called_once()
    api_client.fetch_forecast.assert_not_called()
    cache_client.set.assert_not_called()


@pytest.mark.asyncio
async def test_get_weather_forecast_no_cache_client(api_client):
    forecast = {""temp"": 25}
    api_client.fetch_forecast.return_value = forecast

    result = await get_weather_forecast(
        location=""Berlin"",
        date=datetime.date.today(),
        api_client=api_client,
        cache_client=None,
    )

    assert result == forecast
    api_client.fetch_forecast.assert_awaited_once()


@pytest.mark.asyncio
async def test_get_weather_forecast_past_date_raises(api_client, cache_client):
    past_date = datetime.date.today() - datetime.timedelta(days=1)
    with pytest.raises(ValueError):
        await get_weather_forecast(
            location=""Tokyo"",
            date=past_date,
            api_client=api_client,
            cache_client=cache_client,
        )
    api_client.fetch_forecast.assert_not_called()
    cache_client.get.assert_not_called()


@pytest.mark.asyncio
async def test_get_weather_forecast_api_error_propagates(api_client, cache_client):
    api_client.fetch_forecast.side_effect = ApiError(""service down"")
    cache_client.get.return_value = None

    with pytest.raises(ApiError):
        await get_weather_forecast(
            location=""Sydney"",
            date=datetime.date.today(),
            api_client=api_client,
            cache_client=cache_client,
        )
    api_client.fetch_forecast.assert_awaited_once()
    cache_client.set.assert_not_called()


@pytest.mark.asyncio
async def test_get_weather_forecast_cache_get_error_propagates(api_client, cache_client):
    cache_client.get.side_effect = CacheError(""cache fail"")
    with pytest.raises(CacheError):
        await get_weather_forecast(
            location=""Moscow"",
            date=datetime.date.today(),
            api_client=api_client,
            cache_client=cache_client,
        )
    api_client.fetch_forecast.assert_not_called()


@pytest.mark.asyncio
async def test_get_weather_forecast_cache_set_error_propagates(api_client, cache_client):
    forecast = {""temp"": 10}
    api_client.fetch_forecast.return_value = forecast
    cache_client.get.return_value = None
    cache_client.set.side_effect = CacheError(""set fail"")

    with pytest.raises(CacheError):
        await get_weather_forecast(
            location=""Rome"",
            date=datetime.date.today(),
            api_client=api_client,
            cache_client=cache_client,
        )
    api_client.fetch_forecast.assert_awaited_once()
    cache_client.set.assert_called_once()"
"def generate_report(
    report_type: str,
    start_date: datetime.date,
    end_date: datetime.date,
    db,
    template_engine,
    email_service,
    *,
    send_email: bool = True,
) -> str:
    """"""Generates a formatted report and optionally emails it to stakeholders.

    Args:
        report_type: Identifier of the report to generate (e.g., ``'sales_summary'``).
        start_date: Inclusive start date for the report data.
        end_date: Inclusive end date for the report data; must be on or after ``start_date``.
        db: Database abstraction exposing ``query(sql: str, params: dict) -> List[dict]``.
            Used to fetch raw data for the report.
        template_engine: Service with ``render(template_name: str, context: dict) -> str`` to produce the report body.
        email_service: Service with ``send(to: List[str], subject: str, body: str) -> None`` for email delivery.
        send_email: If ``True``, the generated report is emailed to the recipients defined by the report configuration.
            Defaults to ``True``.

    Returns:
        The rendered report as a string.

    Raises:
        ValueError: If ``start_date`` is after ``end_date`` or ``report_type`` is unsupported.
        DatabaseError: Propagated from ``db`` when the underlying query fails.
        TemplateError: Propagated from ``template_engine`` if rendering fails.
        EmailError: Propagated from ``email_service`` when ``send_email`` is ``True`` and email delivery fails.

    Dependencies:
        - db: Provides ``query`` method for data retrieval.
        - template_engine: Provides ``render`` for report formatting.
        - email_service: Provides ``send`` for optional email distribution.
        - config (optional): Module containing default email recipient lists per ``report_type``.
    """"""","import pytest
from unittest.mock import MagicMock, patch, call
import datetime

from report_module import (
    generate_report,
    DatabaseError,
    TemplateError,
    EmailError,
)


@pytest.fixture
def db_mock():
    return MagicMock()


@pytest.fixture
def template_engine_mock():
    return MagicMock()


@pytest.fixture
def email_service_mock():
    return MagicMock()


def test_generate_report_happy_path_send_email(
    db_mock, template_engine_mock, email_service_mock
):
    start = datetime.date(2023, 1, 1)
    end = datetime.date(2023, 1, 31)
    report_type = ""sales_summary""

    db_mock.query.return_value = [{""total"": 1000}]
    rendered_report = ""<html>Report</html>""
    template_engine_mock.render.return_value = rendered_report

    with patch(""report_module.config"") as config_mock:
        config_mock.RECIPIENTS = {report_type: [""stakeholder@example.com""]}

        result = generate_report(
            report_type,
            start,
            end,
            db=db_mock,
            template_engine=template_engine_mock,
            email_service=email_service_mock,
            send_email=True,
        )

    assert result == rendered_report
    db_mock.query.assert_called_once()
    template_engine_mock.render.assert_called_once_with(
        f""{report_type}.html"", {""data"": [{""total"": 1000}], ""start_date"": start, ""end_date"": end}
    )
    email_service_mock.send.assert_called_once_with(
        [""stakeholder@example.com""],
        f""{report_type} Report"",
        rendered_report,
    )


def test_generate_report_happy_path_no_email(
    db_mock, template_engine_mock, email_service_mock
):
    start = datetime.date(2023, 2, 1)
    end = datetime.date(2023, 2, 28)
    report_type = ""sales_summary""

    db_mock.query.return_value = [{""total"": 2000}]
    rendered_report = ""<html>Report Feb</html>""
    template_engine_mock.render.return_value = rendered_report

    result = generate_report(
        report_type,
        start,
        end,
        db=db_mock,
        template_engine=template_engine_mock,
        email_service=email_service_mock,
        send_email=False,
    )

    assert result == rendered_report
    db_mock.query.assert_called_once()
    template_engine_mock.render.assert_called_once()
    email_service_mock.send.assert_not_called()


def test_generate_report_invalid_date_range(db_mock, template_engine_mock, email_service_mock):
    start = datetime.date(2023, 5, 10)
    end = datetime.date(2023, 5, 1)  # end before start
    with pytest.raises(ValueError):
        generate_report(
            ""sales_summary"",
            start,
            end,
            db=db_mock,
            template_engine=template_engine_mock,
            email_service=email_service_mock,
        )


def test_generate_report_unsupported_type(db_mock, template_engine_mock, email_service_mock):
    start = datetime.date(2023, 3, 1)
    end = datetime.date(2023, 3, 31)
    with pytest.raises(ValueError):
        generate_report(
            ""unknown_type"",
            start,
            end,
            db=db_mock,
            template_engine=template_engine_mock,
            email_service=email_service_mock,
        )


def test_generate_report_propagates_database_error(db_mock, template_engine_mock, email_service_mock):
    start = datetime.date(2023, 4, 1)
    end = datetime.date(2023, 4, 30)
    db_mock.query.side_effect = DatabaseError(""db failure"")
    with pytest.raises(DatabaseError):
        generate_report(
            ""sales_summary"",
            start,
            end,
            db=db_mock,
            template_engine=template_engine_mock,
            email_service=email_service_mock,
        )


def test_generate_report_propagates_template_error(db_mock, template_engine_mock, email_service_mock):
    start = datetime.date(2023, 6, 1)
    end = datetime.date(2023, 6, 30)
    db_mock.query.return_value = [{""total"": 500}]
    template_engine_mock.render.side_effect = TemplateError(""render failure"")
    with pytest.raises(TemplateError):
        generate_report(
            ""sales_summary"",
            start,
            end,
            db=db_mock,
            template_engine=template_engine_mock,
            email_service=email_service_mock,
        )


def test_generate_report_email_error_propagates(db_mock, template_engine_mock, email_service_mock):
    start = datetime.date(2023, 7, 1)
    end = datetime.date(2023, 7, 31)
    db_mock.query.return_value = [{""total"": 750}]
    rendered_report = ""<html>July Report</html>""
    template_engine_mock.render.return_value = rendered_report
    email_service_mock.send.side_effect = EmailError(""smtp failure"")

    with patch(""report_module.config"") as config_mock:
        config_mock.RECIPIENTS = {""sales_summary"": [""stakeholder@example.com""]}

        with pytest.raises(EmailError):
            generate_report(
                ""sales_summary"",
                start,
                end,
                db=db_mock,
                template_engine=template_engine_mock,
                email_service=email_service_mock,
                send_email=True,
            )

    email_service_mock.send.assert_called_once_with(
        [""stakeholder@example.com""],
        ""sales_summary Report"",
        rendered_report,
    )"
"def process_bulk_orders(order_ids: List[int], discount_code: Optional[str] = None) -> Dict[int, str]:
    """"""Process a list of order IDs, apply discount if provided, and update their status.

    Args:
        order_ids: List of integer order identifiers to be processed. The list may be large
            (up to 10,000 items) and must contain only positive integers.
        discount_code: Optional promotional code to apply to each order. Must be a
            valid code according to the PromotionService. If None, no discount is applied.

    Returns:
        Mapping from order ID to a string status:
            - ""processed"" when the order was successfully updated,
            - ""failed"" when the order could not be updated due to a database error,
            - ""skipped"" when the order was ignored because it was already in a terminal state.

        The function guarantees that every input ID appears exactly once in the returned dictionary.

    Raises:
        ValueError: If ``order_ids`` is empty, contains non‑integer values, or contains duplicate IDs.
        PromotionError: If the ``discount_code`` is provided but is invalid, expired, or not applicable to any of the orders.
        DatabaseError: Propagated if the underlying ``OrderRepository`` encounters an unrecoverable error.

    Dependencies:
        - db (OrderRepository): used to fetch current order status and persist updates.
        - promotion_service (PromotionService): validates the ``discount_code`` and calculates discount amounts.
        - logger (logging.Logger): logs each step of the bulk operation with order‑level granularity.
        - metrics (MetricsCollector): records counters for processed, failed, and skipped orders.
    """"""
    pass","import pytest
from unittest.mock import MagicMock, patch

from order_processor import process_bulk_orders, PromotionError, DatabaseError


@pytest.fixture
def mock_db():
    db = MagicMock()
    db.get_status.side_effect = lambda order_id: ""new""
    db.update.return_value = True
    return db


@pytest.fixture
def mock_promotion_service():
    service = MagicMock()
    service.validate.return_value = True
    service.calculate_discount.return_value = 10
    return service


@pytest.fixture
def mock_logger():
    return MagicMock()


@pytest.fixture
def mock_metrics():
    metrics = MagicMock()
    metrics.increment = MagicMock()
    return metrics


def test_process_bulk_orders_happy_path_all_processed(mock_db, mock_promotion_service, mock_logger, mock_metrics):
    order_ids = [1, 2, 3]
    with patch('order_processor.db', mock_db), \
         patch('order_processor.promotion_service', mock_promotion_service), \
         patch('order_processor.logger', mock_logger), \
         patch('order_processor.metrics', mock_metrics):
        result = process_bulk_orders(order_ids, discount_code=""SAVE10"")
    assert result == {1: ""processed"", 2: ""processed"", 3: ""processed""}
    assert mock_promotion_service.validate.called
    assert mock_db.get_status.call_count == 3
    assert mock_db.update.call_count == 3
    mock_metrics.increment.assert_any_call(""processed"")
    mock_metrics.increment.assert_any_call(""skipped"")
    mock_metrics.increment.assert_any_call(""failed"")


def test_process_bulk_orders_skipped_for_terminal_state(mock_db, mock_promotion_service, mock_logger, mock_metrics):
    order_ids = [4, 5]
    mock_db.get_status.side_effect = lambda order_id: ""shipped""
    with patch('order_processor.db', mock_db), \
         patch('order_processor.promotion_service', mock_promotion_service), \
         patch('order_processor.logger', mock_logger), \
         patch('order_processor.metrics', mock_metrics):
        result = process_bulk_orders(order_ids)
    assert result == {4: ""skipped"", 5: ""skipped""}
    assert mock_db.update.call_count == 0
    mock_metrics.increment.assert_any_call(""skipped"")


def test_process_bulk_orders_failed_on_db_error(mock_db, mock_promotion_service, mock_logger, mock_metrics):
    order_ids = [6]
    mock_db.update.side_effect = DatabaseError(""DB failure"")
    with patch('order_processor.db', mock_db), \
         patch('order_processor.promotion_service', mock_promotion_service), \
         patch('order_processor.logger', mock_logger), \
         patch('order_processor.metrics', mock_metrics):
        result = process_bulk_orders(order_ids)
    assert result == {6: ""failed""}
    mock_metrics.increment.assert_any_call(""failed"")


def test_process_bulk_orders_raises_value_error_on_empty_list(mock_logger, mock_metrics):
    with patch('order_processor.logger', mock_logger), \
         patch('order_processor.metrics', mock_metrics):
        with pytest.raises(ValueError):
            process_bulk_orders([])


def test_process_bulk_orders_raises_value_error_on_duplicate_ids(mock_logger, mock_metrics):
    with patch('order_processor.logger', mock_logger), \
         patch('order_processor.metrics', mock_metrics):
        with pytest.raises(ValueError):
            process_bulk_orders([7, 7])


def test_process_bulk_orders_raises_value_error_on_non_int_id(mock_logger, mock_metrics):
    with patch('order_processor.logger', mock_logger), \
         patch('order_processor.metrics', mock_metrics):
        with pytest.raises(ValueError):
            process_bulk_orders([8, ""nine""])


def test_process_bulk_orders_raises_promotion_error_invalid_code(mock_promotion_service, mock_logger, mock_metrics):
    mock_promotion_service.validate.side_effect = PromotionError(""Invalid code"")
    order_ids = [10]
    with patch('order_processor.promotion_service', mock_promotion_service), \
         patch('order_processor.logger', mock_logger), \
         patch('order_processor.metrics', mock_metrics):
        with pytest.raises(PromotionError):
            process_bulk_orders(order_ids, discount_code=""BADCODE"")"
"class NotificationService:
    async def send_bulk_notifications(
        self,
        user_ids: List[int],
        template_id: str,
        api_client: ApiClient,
        cache: RedisCache,
        *,
        retry: int = 3,
    ) -> Dict[int, bool]:
        """"""Sends a notification to multiple users using a template.

        Args:
            user_ids: List of user identifiers to receive the notification.
            template_id: Identifier of the notification template to use.
            api_client: Async client with method ``post(endpoint: str, json: dict) -> Response`` where ``Response`` has ``status_code`` and ``json()``.
            cache: Cache used to store recent send results; implements ``get(key)`` and ``set(key, value, ttl)``.
            retry: Number of retry attempts for failed API calls.

        Returns:
            Mapping of ``user_id`` to a boolean indicating success (``True``) or permanent failure (``False``) after retries.

        Raises:
            ValueError: If ``user_ids`` is empty or ``template_id`` is empty.
            NotificationError: If the API returns a non‑2xx status after all retries.

        Dependencies:
            - ApiClient: async ``post`` method.
            - RedisCache: ``get`` and ``set`` methods.
            - NotificationError: custom exception indicating a fatal notification failure.
        """"""","import pytest
from unittest.mock import AsyncMock, MagicMock, patch

# Assume the implementation resides in `notification_module`
from notification_module import NotificationService, NotificationError


@pytest.fixture
def notification_service():
    return NotificationService()


@pytest.fixture
def mock_api_client():
    client = MagicMock()
    client.post = AsyncMock()
    return client


@pytest.fixture
def mock_cache():
    cache = MagicMock()
    cache.get = MagicMock()
    cache.set = MagicMock()
    return cache


@pytest.mark.asyncio
async def test_send_bulk_notifications_success(
    notification_service,
    mock_api_client,
    mock_cache,
):
    user_ids = [1, 2, 3]
    template_id = ""welcome""
    # cache miss for all users
    mock_cache.get.side_effect = [None, None, None]

    # successful API response
    response = MagicMock()
    response.status_code = 200
    response.json = AsyncMock(return_value={})
    mock_api_client.post.return_value = response

    result = await notification_service.send_bulk_notifications(
        user_ids, template_id, mock_api_client, mock_cache, retry=3
    )

    assert result == {1: True, 2: True, 3: True}
    assert mock_api_client.post.await_count == 3
    mock_api_client.post.assert_has_calls(
        [
            pytest.call(f""/notifications/{template_id}"", {""user_id"": 1}),
            pytest.call(f""/notifications/{template_id}"", {""user_id"": 2}),
            pytest.call(f""/notifications/{template_id}"", {""user_id"": 3}),
        ],
        any_order=False,
    )
    assert mock_cache.set.call_count == 3
    mock_cache.get.assert_has_calls([pytest.call(f""notif:{1}""), pytest.call(f""notif:{2}""), pytest.call(f""notif:{3}"")], any_order=False)


@pytest.mark.asyncio
async def test_send_bulk_notifications_cached(
    notification_service,
    mock_api_client,
    mock_cache,
):
    user_ids = [10, 20]
    template_id = ""alert""
    # first user cached as success, second uncached
    mock_cache.get.side_effect = [True, None]

    response = MagicMock()
    response.status_code = 200
    response.json = AsyncMock(return_value={})
    mock_api_client.post.return_value = response

    result = await notification_service.send_bulk_notifications(
        user_ids, template_id, mock_api_client, mock_cache, retry=2
    )

    assert result == {10: True, 20: True}
    # API should be called only for the uncached user
    mock_api_client.post.assert_awaited_once_with(f""/notifications/{template_id}"", {""user_id"": 20})
    # cache.set should be called only for the uncached user
    mock_cache.set.assert_called_once_with(f""notif:{20}"", True, ttl=ANY)


@pytest.mark.asyncio
async def test_send_bulk_notifications_retry_success(
    notification_service,
    mock_api_client,
    mock_cache,
):
    user_ids = [5]
    template_id = ""reminder""
    mock_cache.get.return_value = None

    # first attempt fails, second succeeds
    fail_response = MagicMock()
    fail_response.status_code = 502
    fail_response.json = AsyncMock(return_value={})
    success_response = MagicMock()
    success_response.status_code = 200
    success_response.json = AsyncMock(return_value={})

    mock_api_client.post.side_effect = [fail_response, success_response]

    result = await notification_service.send_bulk_notifications(
        user_ids, template_id, mock_api_client, mock_cache, retry=2
    )

    assert result == {5: True}
    assert mock_api_client.post.await_count == 2
    mock_api_client.post.assert_has_awaits([pytest.call(f""/notifications/{template_id}"", {""user_id"": 5})] * 2)


@pytest.mark.asyncio
async def test_send_bulk_notifications_permanent_failure_raises(
    notification_service,
    mock_api_client,
    mock_cache,
):
    user_ids = [7]
    template_id = ""promo""
    mock_cache.get.return_value = None

    fail_response = MagicMock()
    fail_response.status_code = 503
    fail_response.json = AsyncMock(return_value={})
    mock_api_client.post.return_value = fail_response

    with pytest.raises(NotificationError):
        await notification_service.send_bulk_notifications(
            user_ids, template_id, mock_api_client, mock_cache, retry=1
        )

    # Should have attempted the post exactly `retry` times
    assert mock_api_client.post.await_count == 1


@pytest.mark.asyncio
async def test_send_bulk_notifications_invalid_inputs(
    notification_service,
    mock_api_client,
    mock_cache,
):
    with pytest.raises(ValueError):
        await notification_service.send_bulk_notifications(
            [], ""tmpl"", mock_api_client, mock_cache
        )
    with pytest.raises(ValueError):
        await notification_service.send_bulk_notifications(
            [1, 2], """", mock_api_client, mock_cache
        )"
"def generate_report(
    report_id: str,
    data_source,
    formatter=None,
    logger: Optional[logging.Logger] = None,
) -> str:
    """"""Generates a CSV report for the given identifier using a data source and an optional formatter.

    Args:
        report_id: Unique identifier of the report to generate.
        data_source: Object exposing ``fetch(report_id: str) -> Iterable[Mapping[str, Any]]``
            which returns rows of data. May raise ``DataSourceError`` on failure.
        formatter (optional): Callable ``format_row(row: Mapping[str, Any]) -> str`` that
            converts a single row to a CSV line. If omitted, a default CSV formatter is used.
        logger (optional): Logger with ``info(message: str)`` and ``error(message: str)`` methods.

    Returns:
        The path to the generated CSV file as a string.

    Raises:
        ValueError: If ``report_id`` is empty.
        DataSourceError: Propagated when ``data_source.fetch`` fails.
        IOError: If writing the report file fails.
        FormatterError: Propagated if the custom ``formatter`` raises an exception.

    Dependencies:
        - data_source: Provides ``fetch`` method returning iterable rows; can raise ``DataSourceError``.
        - formatter (optional): Callable ``format_row``; may raise ``FormatterError``.
        - logger (optional): ``info`` and ``error`` methods for audit logging.
    """"""
    ...","import pytest
from unittest.mock import MagicMock, mock_open, patch, ANY
import importlib

module = importlib.import_module(""target_module"")
generate_report = getattr(module, ""generate_report"")
DataSourceError = getattr(module, ""DataSourceError"", Exception)
FormatterError = getattr(module, ""FormatterError"", Exception)


@pytest.fixture
def mock_data_source():
    return MagicMock()


@pytest.fixture
def mock_logger():
    return MagicMock()


@pytest.fixture
def custom_formatter():
    def fmt(row):
        # simple deterministic CSV line
        return f""{row['id']},{row['value']}\n""
    return fmt


def test_generate_report_success_with_custom_formatter(mock_data_source, mock_logger, custom_formatter):
    report_id = ""RPT123""
    rows = [{""id"": 1, ""value"": ""a""}, {""id"": 2, ""value"": ""b""}]
    mock_data_source.fetch.return_value = rows

    m = mock_open()
    with patch(""builtins.open"", m):
        result_path = generate_report(report_id, mock_data_source, formatter=custom_formatter, logger=mock_logger)

    # verify fetch call
    mock_data_source.fetch.assert_called_once_with(report_id)
    # verify logger usage
    mock_logger.info.assert_called()
    # verify file was opened for writing
    m.assert_called_once()
    opened_path = m.call_args[0][0]
    assert opened_path.endswith("".csv"")
    # verify written content
    handle = m.return_value.__enter__.return_value
    expected_calls = [((custom_formatter(row),),) for row in rows]
    handle.write.assert_has_calls(expected_calls, any_order=False)
    # result should be the path that was opened
    assert result_path == opened_path


def test_generate_report_empty_report_id_raises(mock_data_source, mock_logger):
    with pytest.raises(ValueError):
        generate_report("""", mock_data_source, logger=mock_logger)
    mock_logger.error.assert_called()


def test_generate_report_data_source_error_propagates(mock_data_source, mock_logger):
    mock_data_source.fetch.side_effect = DataSourceError(""fetch failed"")
    with pytest.raises(DataSourceError):
        generate_report(""RPT456"", mock_data_source, logger=mock_logger)
    mock_logger.error.assert_called()


def test_generate_report_formatter_error_propagates(mock_data_source, mock_logger):
    mock_data_source.fetch.return_value = [{""id"": 1, ""value"": ""x""}]

    def bad_formatter(row):
        raise FormatterError(""bad format"")

    with pytest.raises(FormatterError):
        generate_report(""RPT789"", mock_data_source, formatter=bad_formatter, logger=mock_logger)
    mock_logger.error.assert_called()


def test_generate_report_ioerror_on_file_write(mock_data_source, mock_logger):
    mock_data_source.fetch.return_value = [{""id"": 1, ""value"": ""x""}]

    with patch(""builtins.open"", side_effect=IOError):
        with pytest.raises(IOError):
            generate_report(""RPTIO"", mock_data_source, logger=mock_logger)
    mock_logger.error.assert_called()"
"class DataExporter:
    def export_to_csv(
        self,
        records: List[dict],
        file_path: str,
        serializer,
        file_system,
        *,
        delimiter: str = "","",
        include_header: bool = True,
    ) -> None:
        """"""Exports a list of record dictionaries to a CSV file.

        Args:
            records (List[dict]): Collection of records where each dict represents a row.
            file_path (str): Destination path for the CSV file.
            serializer: Object with ``serialize(row: dict) -> List[str]`` converting a record to a list of column strings.
            file_system: Abstraction exposing ``open(path: str, mode: str) -> file`` and ``exists(path: str) -> bool``.
            delimiter (str, optional): Character used to separate fields. Defaults to \"",\"".
            include_header (bool, optional): Whether to write a header row derived from ``serializer``. Defaults to True.

        Returns:
            None

        Raises:
            IOError: If writing to ``file_path`` fails.
            SerializationError: Propagated if ``serializer.serialize`` raises an exception.
            FileExistsError: If ``include_header`` is True and the target file already exists.

        Dependencies:
            - serializer: Provides ``serialize`` method for converting dicts to CSV rows.
            - file_system: Handles file operations; ``open`` may raise ``IOError``.
        """"""","import pytest
from unittest.mock import MagicMock, call
import importlib

module = importlib.import_module(""data_exporter_module"")
DataExporter = getattr(module, ""DataExporter"")
SerializationError = getattr(module, ""SerializationError"", Exception)


@pytest.fixture
def exporter():
    return DataExporter()


@pytest.fixture
def serializer():
    return MagicMock()


@pytest.fixture
def file_system():
    fs = MagicMock()
    mock_file = MagicMock()
    mock_file.write = MagicMock()
    fs.open.return_value = mock_file
    fs.exists.return_value = False
    return fs


def test_export_to_csv_success_with_header(exporter, serializer, file_system):
    records = [
        {""id"": 1, ""name"": ""Alice""},
        {""id"": 2, ""name"": ""Bob""},
    ]
    serializer.serialize.side_effect = [
        [""id"", ""name""],               # assume first call provides header
        [""1"", ""Alice""],
        [""2"", ""Bob""],
    ]

    exporter.export_to_csv(
        records=records,
        file_path=""out.csv"",
        serializer=serializer,
        file_system=file_system,
        delimiter="","",
        include_header=True,
    )

    # open should be called once
    file_system.open.assert_called_once_with(""out.csv"", ""w"")
    mock_file = file_system.open.return_value

    # write should be called header + one per record
    assert mock_file.write.call_count == len(records) + 1
    expected_calls = [
        call(""id,name\n""),
        call(""1,Alice\n""),
        call(""2,Bob\n""),
    ]
    mock_file.write.assert_has_calls(expected_calls, any_order=False)


def test_export_to_csv_success_without_header(exporter, serializer, file_system):
    records = [
        {""id"": 10, ""value"": ""X""},
        {""id"": 20, ""value"": ""Y""},
    ]
    serializer.serialize.side_effect = [
        [""10"", ""X""],
        [""20"", ""Y""],
    ]

    exporter.export_to_csv(
        records=records,
        file_path=""out_no_header.csv"",
        serializer=serializer,
        file_system=file_system,
        delimiter="";"",
        include_header=False,
    )

    file_system.open.assert_called_once_with(""out_no_header.csv"", ""w"")
    mock_file = file_system.open.return_value
    assert mock_file.write.call_count == len(records)
    expected_calls = [
        call(""10;X\n""),
        call(""20;Y\n""),
    ]
    mock_file.write.assert_has_calls(expected_calls, any_order=False)


def test_export_to_csv_file_exists_raises_fileexistserror(exporter, serializer, file_system):
    records = [{""a"": 1}]
    serializer.serialize.return_value = [""a""]
    file_system.exists.return_value = True

    with pytest.raises(FileExistsError):
        exporter.export_to_csv(
            records=records,
            file_path=""already_exists.csv"",
            serializer=serializer,
            file_system=file_system,
            include_header=True,
        )

    file_system.open.assert_not_called()


def test_export_to_csv_serialization_error_propagates(exporter, serializer, file_system):
    records = [{""bad"": ""data""}]
    serializer.serialize.side_effect = SerializationError(""serialization failed"")

    with pytest.raises(SerializationError):
        exporter.export_to_csv(
            records=records,
            file_path=""bad.csv"",
            serializer=serializer,
            file_system=file_system,
        )

    file_system.open.assert_not_called()


def test_export_to_csv_ioerror_propagates(exporter, serializer, file_system):
    records = [{""x"": 1}]
    serializer.serialize.return_value = [""x""]
    file_system.open.side_effect = IOError(""cannot write"")

    with pytest.raises(IOError):
        exporter.export_to_csv(
            records=records,
            file_path=""unwritable.csv"",
            serializer=serializer,
            file_system=file_system,
        )

    file_system.open.assert_called_once_with(""unwritable.csv"", ""w"")"
"def process_order(
    order_id: str,
    items: List[dict],
    payment_gateway,
    config,
    logger: Optional[logging.Logger] = None,
) -> dict:
    """"""Processes an e-commerce order, calculates totals, charges payment, and returns a receipt.

    Args:
        order_id: Unique identifier for the order.
        items: List of item dictionaries each containing ``'price'`` (float) and ``'quantity'`` (int).
        payment_gateway: Object exposing ``charge(amount: float) -> str`` which returns a transaction ID
            or raises ``PaymentError``.
        config: Module providing ``TAX_RATE`` (float) used to compute tax.
        logger (optional): Logger with ``info(message: str)`` and ``error(message: str)`` methods.

    Returns:
        Dictionary with keys ``'order_id'``, ``'total'``, ``'tax'``, ``'transaction_id'`` representing the processed order.

    Raises:
        ValueError: If ``items`` is empty or contains invalid data.
        PaymentError: Propagated if the payment gateway fails.
        Exception: Any unexpected error during processing.

    Dependencies:
        - payment_gateway: ``charge(amount: float) -> str`` may raise ``PaymentError``.
        - config: provides ``TAX_RATE`` constant.
        - logger (optional): ``info`` and ``error`` for logging.
    """"""
    ...","import pytest
from unittest.mock import MagicMock, call
import importlib

module = importlib.import_module(""order_module"")
process_order = getattr(module, ""process_order"")
PaymentError = getattr(module, ""PaymentError"", Exception)


@pytest.fixture
def payment_gateway():
    gateway = MagicMock()
    gateway.charge.return_value = ""tx_12345""
    return gateway


@pytest.fixture
def config():
    cfg = MagicMock()
    cfg.TAX_RATE = 0.1
    return cfg


@pytest.fixture
def logger():
    return MagicMock()


def test_process_order_happy_path(payment_gateway, config, logger):
    order_id = ""order_001""
    items = [
        {""price"": 10.0, ""quantity"": 2},
        {""price"": 5.0, ""quantity"": 3},
    ]  # subtotal = 35.0
    result = process_order(order_id, items, payment_gateway, config, logger)

    subtotal = sum(i[""price""] * i[""quantity""] for i in items)
    expected_tax = subtotal * config.TAX_RATE
    expected_total = subtotal + expected_tax

    assert result[""order_id""] == order_id
    assert result[""tax""] == pytest.approx(expected_tax)
    assert result[""total""] == pytest.approx(expected_total)
    assert result[""transaction_id""] == ""tx_12345""

    payment_gateway.charge.assert_called_once_with(expected_total)
    logger.info.assert_has_calls(
        [
            call(f""Processing order {order_id}""),
            call(f""Subtotal: {subtotal}""),
            call(f""Tax: {expected_tax}""),
            call(f""Total charge amount: {expected_total}""),
            call(f""Payment successful, transaction id: tx_12345""),
        ]
    )


def test_process_order_invalid_empty_items(payment_gateway, config, logger):
    with pytest.raises(ValueError):
        process_order(""order_002"", [], payment_gateway, config, logger)


def test_process_order_invalid_item_missing_fields(payment_gateway, config, logger):
    items = [{""price"": 10.0}]  # missing quantity
    with pytest.raises(ValueError):
        process_order(""order_003"", items, payment_gateway, config, logger)


def test_process_order_invalid_item_negative_values(payment_gateway, config, logger):
    items = [{""price"": -5.0, ""quantity"": 1}]
    with pytest.raises(ValueError):
        process_order(""order_004"", items, payment_gateway, config, logger)


def test_process_order_payment_error_propagates(payment_gateway, config, logger):
    payment_gateway.charge.side_effect = PaymentError(""declined"")
    items = [{""price"": 20.0, ""quantity"": 1}]
    with pytest.raises(PaymentError):
        process_order(""order_005"", items, payment_gateway, config, logger)
    payment_gateway.charge.assert_called_once()
    logger.error.assert_called_once()


def test_process_order_without_logger(payment_gateway, config):
    order_id = ""order_006""
    items = [{""price"": 12.0, ""quantity"": 2}]
    result = process_order(order_id, items, payment_gateway, config)
    subtotal = 24.0
    expected_tax = subtotal * config.TAX_RATE
    expected_total = subtotal + expected_tax

    assert result[""order_id""] == order_id
    assert result[""tax""] == pytest.approx(expected_tax)
    assert result[""total""] == pytest.approx(expected_total)
    assert result[""transaction_id""] == ""tx_12345""
    payment_gateway.charge.assert_called_once_with(expected_total)"
"async def fetch_user_profile(
    user_id: int,
    api_client,
    cache: Optional[Cache] = None,
    logger: Optional[logging.Logger] = None,
) -> dict:
    """"""Retrieves a user profile from a remote service, optionally caching the result.

    Args:
        user_id: Unique identifier of the user. Must be a positive integer.
        api_client: Service client exposing ``get_user(user_id: int) -> dict``. May raise
            ``ApiError`` for network or server problems.
        cache: Optional cache abstraction with ``get(key: str) -> Any`` and ``set(key: str, value: Any, ttl: int)`` methods.
            If provided, successful responses are cached for 300 seconds.
        logger: Optional logger used to record fetch attempts and cache hits/misses. Must implement
            ``info(message: str)`` and ``error(message: str)``.

    Returns:
        A dictionary representing the user profile as returned by ``api_client.get_user``.

    Raises:
        ValueError: If ``user_id`` is not a positive integer.
        ApiError: Propagated if the remote call fails.
        CacheError: Propagated if ``cache`` operations raise an exception.

    Dependencies:
        - api_client: method ``get_user(user_id: int) -> dict``; may raise ``ApiError``.
        - cache (optional): methods ``get(key: str)`` and ``set(key: str, value: Any, ttl: int)``; may raise ``CacheError``.
        - logger (optional): ``info`` and ``error`` methods for logging.
    """"""
    ...

# Dependency specifications
# - api_client: ``get_user(user_id: int)`` returns ``dict``; may raise ``ApiError``.
# - cache (optional): ``get(key: str)`` / ``set(key: str, value: Any, ttl: int)``; may raise ``CacheError``.
# - logger (optional): ``info(message: str)`` and ``error(message: str)``.","import pytest
from unittest.mock import AsyncMock, MagicMock, call, ANY
import importlib

module = importlib.import_module(""user_module"")
fetch_user_profile = module.fetch_user_profile
ApiError = getattr(module, ""ApiError"", Exception)
CacheError = getattr(module, ""CacheError"", Exception)


@pytest.fixture
def mock_api_client():
    client = MagicMock()
    client.get_user = AsyncMock()
    return client


@pytest.fixture
def mock_cache():
    cache = MagicMock()
    cache.get = MagicMock()
    cache.set = MagicMock()
    return cache


@pytest.fixture
def mock_logger():
    return MagicMock()


@pytest.mark.asyncio
async def test_fetch_user_profile_cache_miss(mock_api_client, mock_cache, mock_logger):
    user_id = 42
    profile = {""id"": 42, ""name"": ""Alice""}
    mock_cache.get.return_value = None
    mock_api_client.get_user.return_value = profile

    result = await fetch_user_profile(user_id, mock_api_client, cache=mock_cache, logger=mock_logger)

    assert result == profile
    mock_cache.get.assert_called_once_with(str(user_id))
    mock_api_client.get_user.assert_awaited_once_with(user_id)
    mock_cache.set.assert_called_once_with(str(user_id), profile, ttl=300)
    mock_logger.info.assert_has_calls([call(f""Cache miss for user_id {user_id}""), call(f""Fetched profile for user_id {user_id}"")])


@pytest.mark.asyncio
async def test_fetch_user_profile_cache_hit(mock_api_client, mock_cache, mock_logger):
    user_id = 7
    cached_profile = {""id"": 7, ""name"": ""Bob""}
    mock_cache.get.return_value = cached_profile

    result = await fetch_user_profile(user_id, mock_api_client, cache=mock_cache, logger=mock_logger)

    assert result == cached_profile
    mock_cache.get.assert_called_once_with(str(user_id))
    mock_api_client.get_user.assert_not_called()
    mock_cache.set.assert_not_called()
    mock_logger.info.assert_called_once_with(f""Cache hit for user_id {user_id}"")


@pytest.mark.asyncio
async def test_fetch_user_profile_invalid_user_id(mock_api_client, mock_logger):
    with pytest.raises(ValueError):
        await fetch_user_profile(0, mock_api_client, logger=mock_logger)
    mock_logger.error.assert_called_once()


@pytest.mark.asyncio
async def test_fetch_user_profile_api_error_propagates(mock_api_client, mock_cache, mock_logger):
    user_id = 10
    mock_cache.get.return_value = None
    mock_api_client.get_user.side_effect = ApiError(""network failure"")

    with pytest.raises(ApiError):
        await fetch_user_profile(user_id, mock_api_client, cache=mock_cache, logger=mock_logger)

    mock_cache.get.assert_called_once_with(str(user_id))
    mock_api_client.get_user.assert_awaited_once_with(user_id)
    mock_logger.error.assert_called_once()


@pytest.mark.asyncio
async def test_fetch_user_profile_cache_get_error_propagates(mock_api_client, mock_cache, mock_logger):
    user_id = 5
    mock_cache.get.side_effect = CacheError(""cache get failure"")

    with pytest.raises(CacheError):
        await fetch_user_profile(user_id, mock_api_client, cache=mock_cache, logger=mock_logger)

    mock_cache.get.assert_called_once_with(str(user_id))
    mock_api_client.get_user.assert_not_called()
    mock_logger.error.assert_called_once()


@pytest.mark.asyncio
async def test_fetch_user_profile_cache_set_error_propagates(mock_api_client, mock_cache, mock_logger):
    user_id = 12
    profile = {""id"": 12, ""name"": ""Carol""}
    mock_cache.get.return_value = None
    mock_api_client.get_user.return_value = profile
    mock_cache.set.side_effect = CacheError(""cache set failure"")

    with pytest.raises(CacheError):
        await fetch_user_profile(user_id, mock_api_client, cache=mock_cache, logger=mock_logger)

    mock_cache.get.assert_called_once_with(str(user_id))
    mock_api_client.get_user.assert_awaited_once_with(user_id)
    mock_cache.set.assert_called_once_with(str(user_id), profile, ttl=300)
    mock_logger.error.assert_called_once()"
"class FileSyncService:
    def sync_file(
        self,
        local_path: str,
        remote_path: str,
        cloud_storage,
        checksum_func: Callable[[bytes], str],
        *,
        overwrite: bool = False,
    ) -> bool:
        """"""Synchronizes a local file to remote cloud storage.

        Args:
            local_path: Path to the local file to be uploaded.
            remote_path: Destination path in the cloud storage.
            cloud_storage: Object providing ``upload(path: str, data: bytes) -> None`` and
                ``exists(path: str) -> bool``. May raise ``StorageError``.
            checksum_func: Callable that computes a checksum string from file bytes; used to
                verify that the remote file differs from the local one.
            overwrite: If ``True`` allow overwriting an existing remote file; otherwise
                raise ``FileExistsError`` when the remote file already exists.

        Returns:
            ``True`` if the file was uploaded (or already up‑to‑date); ``False`` if the
            upload was skipped because the remote file is identical and ``overwrite`` is
            ``False``.

        Raises:
            FileNotFoundError: If ``local_path`` does not exist.
            StorageError: Propagated from ``cloud_storage`` operations.
            FileExistsError: If the remote file exists and ``overwrite`` is ``False``.

        Dependencies:
            - cloud_storage: methods ``upload(path: str, data: bytes)`` and ``exists(path: str)``.
            - checksum_func: Callable[[bytes], str] that may raise any exception during checksum calculation.
        """"""
        ...

# Dependency details
# - cloud_storage: ``upload`` and ``exists``; may raise ``StorageError``.
# - checksum_func: Callable for checksum generation.","import pytest
from unittest.mock import MagicMock, mock_open, patch

# Assume the module containing FileSyncService is named file_sync_service
from file_sync_service import FileSyncService, StorageError


@pytest.fixture
def mock_cloud_storage():
    return MagicMock()


@pytest.fixture
def checksum_func():
    return MagicMock(return_value=""checksum"")


def test_sync_file_upload_when_remote_missing(mock_cloud_storage, checksum_func):
    mock_cloud_storage.exists.return_value = False
    file_data = b""file contents""
    with patch(""builtins.open"", mock_open(read_data=file_data)):
        service = FileSyncService()
        result = service.sync_file(
            local_path=""/local/path.txt"",
            remote_path=""/remote/path.txt"",
            cloud_storage=mock_cloud_storage,
            checksum_func=checksum_func,
        )
    assert result is True
    mock_cloud_storage.upload.assert_called_once_with(""/remote/path.txt"", file_data)
    mock_cloud_storage.exists.assert_called_once_with(""/remote/path.txt"")
    checksum_func.assert_called_once()


def test_sync_file_overwrite_true(mock_cloud_storage, checksum_func):
    mock_cloud_storage.exists.return_value = True
    file_data = b""new content""
    with patch(""builtins.open"", mock_open(read_data=file_data)):
        service = FileSyncService()
        result = service.sync_file(
            local_path=""/local/new.txt"",
            remote_path=""/remote/existing.txt"",
            cloud_storage=mock_cloud_storage,
            checksum_func=checksum_func,
            overwrite=True,
        )
    assert result is True
    mock_cloud_storage.upload.assert_called_once_with(""/remote/existing.txt"", file_data)
    mock_cloud_storage.exists.assert_called_once_with(""/remote/existing.txt"")
    checksum_func.assert_called_once()


def test_sync_file_raises_file_not_found(mock_cloud_storage, checksum_func):
    with patch(""builtins.open"", side_effect=FileNotFoundError):
        service = FileSyncService()
        with pytest.raises(FileNotFoundError):
            service.sync_file(
                local_path=""/nonexistent/file.txt"",
                remote_path=""/remote/file.txt"",
                cloud_storage=mock_cloud_storage,
                checksum_func=checksum_func,
            )
    mock_cloud_storage.upload.assert_not_called()
    mock_cloud_storage.exists.assert_not_called()
    checksum_func.assert_not_called()


def test_sync_file_propagates_storage_error(mock_cloud_storage, checksum_func):
    mock_cloud_storage.exists.return_value = False
    mock_cloud_storage.upload.side_effect = StorageError(""upload failed"")
    file_data = b""data""
    with patch(""builtins.open"", mock_open(read_data=file_data)):
        service = FileSyncService()
        with pytest.raises(StorageError):
            service.sync_file(
                local_path=""/local/file.txt"",
                remote_path=""/remote/file.txt"",
                cloud_storage=mock_cloud_storage,
                checksum_func=checksum_func,
            )
    mock_cloud_storage.upload.assert_called_once_with(""/remote/file.txt"", file_data)
    mock_cloud_storage.exists.assert_called_once_with(""/remote/file.txt"")
    checksum_func.assert_called_once()


def test_sync_file_raises_file_exists_error_when_remote_exists_and_no_overwrite(mock_cloud_storage, checksum_func):
    mock_cloud_storage.exists.return_value = True
    file_data = b""content""
    with patch(""builtins.open"", mock_open(read_data=file_data)):
        service = FileSyncService()
        with pytest.raises(FileExistsError):
            service.sync_file(
                local_path=""/local/file.txt"",
                remote_path=""/remote/file.txt"",
                cloud_storage=mock_cloud_storage,
                checksum_func=checksum_func,
                overwrite=False,
            )
    mock_cloud_storage.upload.assert_not_called()
    mock_cloud_storage.exists.assert_called_once_with(""/remote/file.txt"")
    checksum_func.assert_called_once()"
"def calculate_discount(
    price: float,
    user,
    discount_service,
    cache=None,
    logger=None,
) -> float:
    """"""Calculates the discounted price for a user using a discount service.

    Args:
        price: Original price of the item. Must be non‑negative.
        user: User object with attribute ``id`` used to lookup personalized discounts.
        discount_service: Service exposing ``get_discount(user_id: int) -> float`` that returns a discount
            fraction between ``0`` and ``1``. May raise ``DiscountServiceError``.
        cache (optional): Mapping with ``get(key)`` and ``set(key, value)`` used to cache discount fractions.
        logger (optional): Logger with ``debug`` and ``warning`` methods.

    Returns:
        The price after applying the discount. If no discount is applicable, returns the original ``price``.

    Raises:
        ValueError: If ``price`` is negative.
        DiscountServiceError: Propagated when ``discount_service.get_discount`` fails.
        CacheError: Propagated from ``cache`` operations if present.

    Dependencies:
        - discount_service: method ``get_discount(user_id: int) -> float``; may raise ``DiscountServiceError``.
        - cache (optional): simple key/value store; may raise ``CacheError``.
        - logger (optional): logging interface.
    """"""
    ...

# Dependency details
# - discount_service: ``get_discount(user_id: int) -> float``; may raise ``DiscountServiceError``.
# - cache (optional): Mapping with ``get``/``set`` methods; may raise ``CacheError``.
# - logger (optional): ``debug`` / ``warning`` methods.","import pytest
from unittest.mock import MagicMock, call
import importlib

module = importlib.import_module(""target_module"")
calculate_discount = getattr(module, ""calculate_discount"")
DiscountServiceError = getattr(module, ""DiscountServiceError"", Exception)
CacheError = getattr(module, ""CacheError"", Exception)


@pytest.fixture
def user():
    obj = MagicMock()
    obj.id = 42
    return obj


@pytest.fixture
def discount_service():
    return MagicMock()


@pytest.fixture
def cache():
    return MagicMock()


@pytest.fixture
def logger():
    return MagicMock()


def test_calculate_discount_cache_miss(user, discount_service, cache, logger):
    price = 100.0
    cache.get.return_value = None
    discount_service.get_discount.return_value = 0.2

    result = calculate_discount(price, user, discount_service, cache=cache, logger=logger)

    assert result == pytest.approx(80.0)
    cache.get.assert_called_once_with(f""user_discount:{user.id}"")
    discount_service.get_discount.assert_called_once_with(user.id)
    cache.set.assert_called_once_with(f""user_discount:{user.id}"", 0.2)
    logger.debug.assert_called()
    logger.warning.assert_not_called()


def test_calculate_discount_cache_hit(user, discount_service, cache, logger):
    price = 50.0
    cache.get.return_value = 0.15

    result = calculate_discount(price, user, discount_service, cache=cache, logger=logger)

    assert result == pytest.approx(42.5)
    cache.get.assert_called_once_with(f""user_discount:{user.id}"")
    discount_service.get_discount.assert_not_called()
    cache.set.assert_not_called()
    logger.debug.assert_called()
    logger.warning.assert_not_called()


def test_calculate_discount_no_discount(user, discount_service, cache, logger):
    price = 75.0
    cache.get.return_value = 0.0

    result = calculate_discount(price, user, discount_service, cache=cache, logger=logger)

    assert result == pytest.approx(75.0)
    cache.get.assert_called_once_with(f""user_discount:{user.id}"")
    discount_service.get_discount.assert_not_called()
    logger.debug.assert_called()


def test_calculate_discount_negative_price_raises(user, discount_service, cache, logger):
    with pytest.raises(ValueError):
        calculate_discount(-10.0, user, discount_service, cache=cache, logger=logger)
    cache.get.assert_not_called()
    discount_service.get_discount.assert_not_called()
    logger.debug.assert_not_called()


def test_calculate_discount_service_error_propagates(user, discount_service, cache, logger):
    price = 120.0
    cache.get.return_value = None
    discount_service.get_discount.side_effect = DiscountServiceError(""service failure"")

    with pytest.raises(DiscountServiceError):
        calculate_discount(price, user, discount_service, cache=cache, logger=logger)

    cache.get.assert_called_once_with(f""user_discount:{user.id}"")
    discount_service.get_discount.assert_called_once_with(user.id)
    cache.set.assert_not_called()


def test_calculate_discount_cache_get_error_propagates(user, discount_service, cache, logger):
    price = 80.0
    cache.get.side_effect = CacheError(""get error"")

    with pytest.raises(CacheError):
        calculate_discount(price, user, discount_service, cache=cache, logger=logger)

    cache.get.assert_called_once_with(f""user_discount:{user.id}"")
    discount_service.get_discount.assert_not_called()


def test_calculate_discount_cache_set_error_propagates(user, discount_service, cache, logger):
    price = 200.0
    cache.get.return_value = None
    discount_service.get_discount.return_value = 0.25
    cache.set.side_effect = CacheError(""set error"")

    with pytest.raises(CacheError):
        calculate_discount(price, user, discount_service, cache=cache, logger=logger)

    cache.get.assert_called_once_with(f""user_discount:{user.id}"")
    discount_service.get_discount.assert_called_once_with(user.id)
    cache.set.assert_called_once_with(f""user_discount:{user.id}"", 0.25)"
