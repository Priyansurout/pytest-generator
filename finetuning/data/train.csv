question,answer,context,"reasoning"
"def calculate_discount(price: float, discount_percent: float) -> float:
    """"""
    Calculate the final price after applying a discount.
    
    Args:
        price: Original price of the item
        discount_percent: Discount percentage (0-100)
    
    Returns:
        Final price after discount
    
    Raises:
        ValueError: If price is negative or discount_percent is not in range 0-100
    """"""","import pytest

def test_calculate_discount():
    assert calculate_discount(100.0, 10.0) == 90.0
    assert calculate_discount(50.0, 20.0) == 40.0
    assert calculate_discount(200.0, 0.0) == 200.0

def test_calculate_discount_edge_cases():
    assert calculate_discount(100.0, 100.0) == 0.0
    assert calculate_discount(0.0, 50.0) == 0.0

def test_calculate_discount_raises_value_error():
    with pytest.raises(ValueError):
        calculate_discount(-10.0, 10.0)
    with pytest.raises(ValueError):
        calculate_discount(100.0, -5.0)
    with pytest.raises(ValueError):
        calculate_discount(100.0, 150.0)",,
"def fetch_user_data(user_id: int, api_client) -> dict:
    """"""
    Fetch user data from an external API.
    
    Args:
        user_id: The ID of the user to fetch
        api_client: API client instance
    
    Returns:
        Dictionary containing user data
    
    Raises:
        ConnectionError: If API is unreachable
        ValueError: If user_id is invalid
    
    # Dependencies: api_client.get()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""user_id,expected_data"", [
    (1, {""id"": 1, ""name"": ""Alice""}),
    (2, {""id"": 2, ""name"": ""Bob""}),
    (999, {""id"": 999, ""name"": ""Test User""}),
])
def test_fetch_user_data(user_id, expected_data):
    mock_api = Mock()
    mock_api.get.return_value = expected_data
    result = fetch_user_data(user_id, mock_api)
    assert result == expected_data
    mock_api.get.assert_called_once_with(f""/users/{user_id}"")

def test_fetch_user_data_connection_error():
    mock_api = Mock()
    mock_api.get.side_effect = ConnectionError(""API unreachable"")
    with pytest.raises(ConnectionError):
        fetch_user_data(1, mock_api)

def test_fetch_user_data_invalid_id():
    mock_api = Mock()
    with pytest.raises(ValueError):
        fetch_user_data(-1, mock_api)",,
"def process_payment(amount: float, payment_gateway, send_receipt) -> str:
    """"""
    Process a payment and send receipt.
    
    Args:
        amount: Payment amount in dollars
        payment_gateway: Payment processing service
        send_receipt: Function to send receipt email
    
    Returns:
        Transaction ID as string
    
    Raises:
        ValueError: If amount is negative or zero
        RuntimeError: If payment processing fails
    
    # Dependencies: payment_gateway.charge(), send_receipt()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""amount,expected_tx_id"", [
    (50.0, ""TX-001""),
    (100.5, ""TX-002""),
    (999.99, ""TX-003""),
])
def test_process_payment(amount, expected_tx_id):
    mock_gateway = Mock()
    mock_gateway.charge.return_value = expected_tx_id
    mock_send = Mock()
    result = process_payment(amount, mock_gateway, mock_send)
    assert result == expected_tx_id
    mock_gateway.charge.assert_called_once_with(amount)
    mock_send.assert_called_once_with(expected_tx_id, amount)

def test_process_payment_invalid_amount():
    mock_gateway = Mock()
    mock_send = Mock()
    with pytest.raises(ValueError):
        process_payment(0.0, mock_gateway, mock_send)
    with pytest.raises(ValueError):
        process_payment(-10.0, mock_gateway, mock_send)

def test_process_payment_gateway_failure():
    mock_gateway = Mock()
    mock_gateway.charge.side_effect = RuntimeError(""Payment failed"")
    mock_send = Mock()
    with pytest.raises(RuntimeError):
        process_payment(100.0, mock_gateway, mock_send)",,
"def validate_email(email: str) -> bool:
    """"""
    Validate email address format.
    
    Args:
        email: Email address string to validate
    
    Returns:
        True if valid, False otherwise
    
    Raises:
        TypeError: If email is not a string
    """"""","import pytest

@pytest.mark.parametrize(""email,expected"", [
    (""user@example.com"", True),
    (""test.user@domain.co.uk"", True),
    (""invalid.email"", False),
    (""@example.com"", False),
    (""user@"", False),
])
def test_validate_email(email, expected):
    assert validate_email(email) == expected

def test_validate_email_edge_cases():
    assert validate_email("""") == False
    assert validate_email(""a@b.c"") == True

def test_validate_email_type_error():
    with pytest.raises(TypeError):
        validate_email(123)
    with pytest.raises(TypeError):
        validate_email(None)",,
"def merge_configs(base_config: dict, override_config: dict, validator) -> dict:
    """"""
    Merge two configuration dictionaries with validation.
    
    Args:
        base_config: Base configuration dictionary
        override_config: Configuration values to override
        validator: Function to validate merged config
    
    Returns:
        Merged and validated configuration dictionary
    
    Raises:
        ValueError: If validation fails
        TypeError: If inputs are not dictionaries
    
    # Dependencies: validator()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""base,override,expected"", [
    ({""a"": 1}, {""b"": 2}, {""a"": 1, ""b"": 2}),
    ({""x"": 10}, {""x"": 20}, {""x"": 20}),
    ({}, {""key"": ""value""}, {""key"": ""value""}),
])
def test_merge_configs(base, override, expected):
    mock_validator = Mock(return_value=True)
    result = merge_configs(base, override, mock_validator)
    assert result == expected
    mock_validator.assert_called_once_with(expected)

def test_merge_configs_validation_failure():
    mock_validator = Mock(return_value=False)
    with pytest.raises(ValueError):
        merge_configs({""a"": 1}, {""b"": 2}, mock_validator)

def test_merge_configs_type_error():
    mock_validator = Mock()
    with pytest.raises(TypeError):
        merge_configs(""not_dict"", {}, mock_validator)
    with pytest.raises(TypeError):
        merge_configs({}, ""not_dict"", mock_validator)",,
"def calculate_average(numbers: list[float]) -> float:
    """"""
    Calculate the average of a list of numbers.
    
    Args:
        numbers: List of numeric values
    
    Returns:
        Average value as float
    
    Raises:
        ValueError: If list is empty
        TypeError: If list contains non-numeric values
    """"""","import pytest

@pytest.mark.parametrize(""numbers,expected"", [
    ([1.0, 2.0, 3.0], 2.0),
    ([10.0, 20.0], 15.0),
    ([5.5], 5.5),
])
def test_calculate_average(numbers, expected):
    assert calculate_average(numbers) == expected

def test_calculate_average_empty_list():
    with pytest.raises(ValueError):
        calculate_average([])

def test_calculate_average_type_error():
    with pytest.raises(TypeError):
        calculate_average([1, 2, ""three""])
    with pytest.raises(TypeError):
        calculate_average([1, None, 3])",,
"def retry_operation(operation, max_retries: int, logger) -> any:
    """"""
    Retry an operation with exponential backoff.
    
    Args:
        operation: Callable to execute
        max_retries: Maximum number of retry attempts
        logger: Logger instance for recording attempts
    
    Returns:
        Result from successful operation execution
    
    Raises:
        RuntimeError: If all retries are exhausted
        ValueError: If max_retries is less than 1
    
    # Dependencies: operation(), logger.info(), logger.error()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""max_retries,expected_result"", [
    (3, ""success""),
    (1, ""success""),
    (5, ""success""),
])
def test_retry_operation_success(max_retries, expected_result):
    mock_op = Mock(return_value=expected_result)
    mock_logger = Mock()
    result = retry_operation(mock_op, max_retries, mock_logger)
    assert result == expected_result
    mock_op.assert_called_once()
    assert mock_logger.info.called

def test_retry_operation_exhausted_retries():
    mock_op = Mock(side_effect=Exception(""Failed""))
    mock_logger = Mock()
    with pytest.raises(RuntimeError):
        retry_operation(mock_op, 3, mock_logger)
    assert mock_op.call_count == 3
    assert mock_logger.error.called

def test_retry_operation_invalid_max_retries():
    mock_op = Mock()
    mock_logger = Mock()
    with pytest.raises(ValueError):
        retry_operation(mock_op, 0, mock_logger)",,
"def parse_json_file(filepath: str, file_reader) -> dict:
    """"""
    Parse JSON from a file.
    
    Args:
        filepath: Path to JSON file
        file_reader: Function to read file contents
    
    Returns:
        Parsed JSON as dictionary
    
    Raises:
        FileNotFoundError: If file doesn't exist
        ValueError: If JSON is invalid
    
    # Dependencies: file_reader()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""filepath,json_content,expected"", [
    (""config.json"", '{""key"": ""value""}', {""key"": ""value""}),
    (""data.json"", '{""num"": 42}', {""num"": 42}),
    (""/path/to/file.json"", '{""list"": [1, 2, 3]}', {""list"": [1, 2, 3]}),
])
def test_parse_json_file(filepath, json_content, expected):
    mock_reader = Mock(return_value=json_content)
    result = parse_json_file(filepath, mock_reader)
    assert result == expected
    mock_reader.assert_called_once_with(filepath)

def test_parse_json_file_not_found():
    mock_reader = Mock(side_effect=FileNotFoundError(""File not found""))
    with pytest.raises(FileNotFoundError):
        parse_json_file(""missing.json"", mock_reader)

def test_parse_json_file_invalid_json():
    mock_reader = Mock(return_value=""{invalid json}"")
    with pytest.raises(ValueError):
        parse_json_file(""bad.json"", mock_reader)",,
"def format_currency(amount: float, currency_code: str) -> str:
    """"""
    Format amount as currency string.
    
    Args:
        amount: Numeric amount to format
        currency_code: ISO currency code (USD, EUR, etc.)
    
    Returns:
        Formatted currency string
    
    Raises:
        ValueError: If currency_code is not supported
    """"""","import pytest

@pytest.mark.parametrize(""amount,currency,expected"", [
    (100.50, ""USD"", ""$100.50""),
    (50.0, ""EUR"", ""€50.00""),
    (999.99, ""GBP"", ""£999.99""),
])
def test_format_currency(amount, currency, expected):
    assert format_currency(amount, currency) == expected

def test_format_currency_edge_cases():
    assert format_currency(0.0, ""USD"") == ""$0.00""
    assert format_currency(1000000.0, ""USD"") == ""$1,000,000.00""

def test_format_currency_unsupported_code():
    with pytest.raises(ValueError):
        format_currency(100.0, ""XYZ"")
    with pytest.raises(ValueError):
        format_currency(100.0, """")",,
"def send_notification(user_id: int, message: str, sms_sender, email_sender) -> dict:
    """"""
    Send notification via SMS and email.
    
    Args:
        user_id: User identifier
        message: Notification message
        sms_sender: SMS sending service
        email_sender: Email sending service
    
    Returns:
        Dictionary with delivery status for each channel
    
    Raises:
        ValueError: If message is empty
        ConnectionError: If both channels fail
    
    # Dependencies: sms_sender.send(), email_sender.send()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""user_id,message"", [
    (1, ""Test message""),
    (999, ""Important alert""),
    (42, ""Hello world""),
])
def test_send_notification(user_id, message):
    mock_sms = Mock()
    mock_sms.send.return_value = True
    mock_email = Mock()
    mock_email.send.return_value = True
    result = send_notification(user_id, message, mock_sms, mock_email)
    assert result[""sms""] == True
    assert result[""email""] == True
    mock_sms.send.assert_called_once_with(user_id, message)
    mock_email.send.assert_called_once_with(user_id, message)

def test_send_notification_empty_message():
    mock_sms = Mock()
    mock_email = Mock()
    with pytest.raises(ValueError):
        send_notification(1, """", mock_sms, mock_email)

def test_send_notification_both_fail():
    mock_sms = Mock()
    mock_sms.send.side_effect = ConnectionError(""SMS failed"")
    mock_email = Mock()
    mock_email.send.side_effect = ConnectionError(""Email failed"")
    with pytest.raises(ConnectionError):
        send_notification(1, ""Test"", mock_sms, mock_email)",,
"def generate_report(data: list[dict], template_engine, export_pdf) -> str:
    """"""
    Generate PDF report from data.
    
    Args:
        data: List of data dictionaries
        template_engine: Template rendering engine
        export_pdf: PDF export function
    
    Returns:
        Path to generated PDF file
    
    Raises:
        ValueError: If data is empty
        RuntimeError: If PDF generation fails
    
    # Dependencies: template_engine.render(), export_pdf()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""data,expected_path"", [
    ([{""id"": 1, ""value"": 100}], ""/reports/report_1.pdf""),
    ([{""id"": 2, ""value"": 200}, {""id"": 3, ""value"": 300}], ""/reports/report_2.pdf""),
])
def test_generate_report(data, expected_path):
    mock_template = Mock()
    mock_template.render.return_value = ""<html>Report</html>""
    mock_export = Mock(return_value=expected_path)
    result = generate_report(data, mock_template, mock_export)
    assert result == expected_path
    mock_template.render.assert_called_once_with(data)
    mock_export.assert_called_once_with(""<html>Report</html>"")

def test_generate_report_empty_data():
    mock_template = Mock()
    mock_export = Mock()
    with pytest.raises(ValueError):
        generate_report([], mock_template, mock_export)

def test_generate_report_export_failure():
    mock_template = Mock()
    mock_template.render.return_value = ""<html>Report</html>""
    mock_export = Mock(side_effect=RuntimeError(""Export failed""))
    with pytest.raises(RuntimeError):
        generate_report([{""id"": 1}], mock_template, mock_export)",,
"def cache_get_or_compute(key: str, cache, compute_fn) -> any:
    """"""
    Get value from cache or compute if missing.
    
    Args:
        key: Cache key
        cache: Cache storage instance
        compute_fn: Function to compute value if not cached
    
    Returns:
        Cached or computed value
    
    Raises:
        KeyError: If key is invalid
        RuntimeError: If compute function fails
    
    # Dependencies: cache.get(), cache.set(), compute_fn()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""key,cached_value"", [
    (""user:123"", {""name"": ""Alice""}),
    (""product:456"", {""price"": 99.99}),
])
def test_cache_get_cached_value(key, cached_value):
    mock_cache = Mock()
    mock_cache.get.return_value = cached_value
    mock_compute = Mock()
    result = cache_get_or_compute(key, mock_cache, mock_compute)
    assert result == cached_value
    mock_cache.get.assert_called_once_with(key)
    mock_compute.assert_not_called()

def test_cache_get_compute_missing():
    mock_cache = Mock()
    mock_cache.get.return_value = None
    mock_compute = Mock(return_value={""computed"": ""value""})
    result = cache_get_or_compute(""missing:key"", mock_cache, mock_compute)
    assert result == {""computed"": ""value""}
    mock_cache.set.assert_called_once_with(""missing:key"", {""computed"": ""value""})

def test_cache_get_compute_failure():
    mock_cache = Mock()
    mock_cache.get.return_value = None
    mock_compute = Mock(side_effect=RuntimeError(""Compute failed""))
    with pytest.raises(RuntimeError):
        cache_get_or_compute(""key"", mock_cache, mock_compute)",,
"def batch_process_items(items: list, processor, error_handler) -> dict:
    """"""
    Process items in batch with error handling.
    
    Args:
        items: List of items to process
        processor: Function to process each item
        error_handler: Function to handle processing errors
    
    Returns:
        Dictionary with 'success' and 'failed' counts
    
    Raises:
        ValueError: If items list is empty
    
    # Dependencies: processor(), error_handler()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""items,expected_success"", [
    ([1, 2, 3], 3),
    ([""a"", ""b""], 2),
])
def test_batch_process_all_success(items, expected_success):
    mock_processor = Mock(return_value=True)
    mock_error_handler = Mock()
    result = batch_process_items(items, mock_processor, mock_error_handler)
    assert result[""success""] == expected_success
    assert result[""failed""] == 0
    assert mock_processor.call_count == expected_success
    mock_error_handler.assert_not_called()

def test_batch_process_with_errors():
    mock_processor = Mock(side_effect=[True, Exception(""Error""), True])
    mock_error_handler = Mock()
    result = batch_process_items([1, 2, 3], mock_processor, mock_error_handler)
    assert result[""success""] == 2
    assert result[""failed""] == 1
    mock_error_handler.assert_called_once()

def test_batch_process_empty_items():
    mock_processor = Mock()
    mock_error_handler = Mock()
    with pytest.raises(ValueError):
        batch_process_items([], mock_processor, mock_error_handler)",,
"def authenticate_user(username: str, password: str, auth_service, session_manager) -> str:
    """"""
    Authenticate user and create session.
    
    Args:
        username: User's username
        password: User's password
        auth_service: Authentication service
        session_manager: Session management service
    
    Returns:
        Session token as string
    
    Raises:
        ValueError: If credentials are invalid
        ConnectionError: If auth service is unavailable
    
    # Dependencies: auth_service.verify(), session_manager.create()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""username,password,expected_token"", [
    (""alice"", ""pass123"", ""token-abc""),
    (""bob"", ""secret"", ""token-xyz""),
])
def test_authenticate_user(username, password, expected_token):
    mock_auth = Mock()
    mock_auth.verify.return_value = True
    mock_session = Mock()
    mock_session.create.return_value = expected_token
    result = authenticate_user(username, password, mock_auth, mock_session)
    assert result == expected_token
    mock_auth.verify.assert_called_once_with(username, password)
    mock_session.create.assert_called_once_with(username)

def test_authenticate_user_invalid_credentials():
    mock_auth = Mock()
    mock_auth.verify.return_value = False
    mock_session = Mock()
    with pytest.raises(ValueError):
        authenticate_user(""user"", ""wrong"", mock_auth, mock_session)

def test_authenticate_user_service_unavailable():
    mock_auth = Mock()
    mock_auth.verify.side_effect = ConnectionError(""Service down"")
    mock_session = Mock()
    with pytest.raises(ConnectionError):
        authenticate_user(""user"", ""pass"", mock_auth, mock_session)",,
"def transform_data(input_data: dict, transformer, validator) -> dict:
    """"""
    Transform and validate data.
    
    Args:
        input_data: Input dictionary to transform
        transformer: Data transformation function
        validator: Data validation function
    
    Returns:
        Transformed and validated dictionary
    
    Raises:
        ValueError: If validation fails
        TypeError: If input_data is not a dictionary
    
    # Dependencies: transformer(), validator()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""input_data,transformed"", [
    ({""x"": 1}, {""x"": 2}),
    ({""name"": ""test""}, {""name"": ""TEST""}),
])
def test_transform_data(input_data, transformed):
    mock_transformer = Mock(return_value=transformed)
    mock_validator = Mock(return_value=True)
    result = transform_data(input_data, mock_transformer, mock_validator)
    assert result == transformed
    mock_transformer.assert_called_once_with(input_data)
    mock_validator.assert_called_once_with(transformed)

def test_transform_data_validation_failure():
    mock_transformer = Mock(return_value={""invalid"": ""data""})
    mock_validator = Mock(return_value=False)
    with pytest.raises(ValueError):
        transform_data({""x"": 1}, mock_transformer, mock_validator)

def test_transform_data_type_error():
    mock_transformer = Mock()
    mock_validator = Mock()
    with pytest.raises(TypeError):
        transform_data(""not_dict"", mock_transformer, mock_validator)",,
"def schedule_job(job_id: str, cron_expr: str, scheduler, notifier) -> bool:
    """"""
    Schedule a job with cron expression.
    
    Args:
        job_id: Unique job identifier
        cron_expr: Cron expression for scheduling
        scheduler: Job scheduling service
        notifier: Notification service for job events
    
    Returns:
        True if job scheduled successfully
    
    Raises:
        ValueError: If cron expression is invalid
        RuntimeError: If scheduling fails
    
    # Dependencies: scheduler.add_job(), notifier.send()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""job_id,cron_expr"", [
    (""job-1"", ""0 0 * * *""),
    (""job-2"", ""*/5 * * * *""),
])
def test_schedule_job(job_id, cron_expr):
    mock_scheduler = Mock()
    mock_scheduler.add_job.return_value = True
    mock_notifier = Mock()
    result = schedule_job(job_id, cron_expr, mock_scheduler, mock_notifier)
    assert result == True
    mock_scheduler.add_job.assert_called_once_with(job_id, cron_expr)
    mock_notifier.send.assert_called_once()

def test_schedule_job_invalid_cron():
    mock_scheduler = Mock()
    mock_notifier = Mock()
    with pytest.raises(ValueError):
        schedule_job(""job-1"", ""invalid-cron"", mock_scheduler, mock_notifier)

def test_schedule_job_scheduling_failure():
    mock_scheduler = Mock()
    mock_scheduler.add_job.side_effect = RuntimeError(""Scheduling failed"")
    mock_notifier = Mock()
    with pytest.raises(RuntimeError):
        schedule_job(""job-1"", ""0 0 * * *"", mock_scheduler, mock_notifier)",,
"def export_to_csv(data: list[dict], filepath: str, file_writer) -> int:
    """"""
    Export data to CSV file.
    
    Args:
        data: List of dictionaries to export
        filepath: Destination file path
        file_writer: File writing function
    
    Returns:
        Number of rows written
    
    Raises:
        ValueError: If data is empty
        IOError: If file writing fails
    
    # Dependencies: file_writer()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""data,expected_rows"", [
    ([{""id"": 1, ""name"": ""Alice""}], 1),
    ([{""id"": 1}, {""id"": 2}, {""id"": 3}], 3),
])
def test_export_to_csv(data, expected_rows):
    mock_writer = Mock()
    result = export_to_csv(data, ""output.csv"", mock_writer)
    assert result == expected_rows
    mock_writer.assert_called_once()

def test_export_to_csv_empty_data():
    mock_writer = Mock()
    with pytest.raises(ValueError):
        export_to_csv([], ""output.csv"", mock_writer)

def test_export_to_csv_write_failure():
    mock_writer = Mock(side_effect=IOError(""Write failed""))
    with pytest.raises(IOError):
        export_to_csv([{""id"": 1}], ""output.csv"", mock_writer)",,
"def fetch_and_parse(url: str, http_client, parser) -> dict:
    """"""
    Fetch content from URL and parse it.
    
    Args:
        url: URL to fetch content from
        http_client: HTTP client instance
        parser: Content parsing function
    
    Returns:
        Parsed content as dictionary
    
    Raises:
        ConnectionError: If URL is unreachable
        ValueError: If parsing fails
    
    # Dependencies: http_client.get(), parser()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""url,content,parsed"", [
    (""http://api.example.com/data"", '{""key"": ""value""}', {""key"": ""value""}),
    (""https://example.com/json"", '{""id"": 123}', {""id"": 123}),
])
def test_fetch_and_parse(url, content, parsed):
    mock_client = Mock()
    mock_client.get.return_value = content
    mock_parser = Mock(return_value=parsed)
    result = fetch_and_parse(url, mock_client, mock_parser)
    assert result == parsed
    mock_client.get.assert_called_once_with(url)
    mock_parser.assert_called_once_with(content)

def test_fetch_and_parse_connection_error():
    mock_client = Mock()
    mock_client.get.side_effect = ConnectionError(""Unreachable"")
    mock_parser = Mock()
    with pytest.raises(ConnectionError):
        fetch_and_parse(""http://example.com"", mock_client, mock_parser)

def test_fetch_and_parse_parse_error():
    mock_client = Mock()
    mock_client.get.return_value = ""invalid content""
    mock_parser = Mock(side_effect=ValueError(""Parse failed""))
    with pytest.raises(ValueError):
        fetch_and_parse(""http://example.com"", mock_client, mock_parser)",,
"def sync_database(source_db, target_db, logger) -> dict:
    """"""
    Synchronize data between two databases.
    
    Args:
        source_db: Source database connection
        target_db: Target database connection
        logger: Logger for sync operations
    
    Returns:
        Dictionary with sync statistics
    
    Raises:
        ConnectionError: If database connection fails
        RuntimeError: If sync operation fails
    
    # Dependencies: source_db.fetch_all(), target_db.insert_batch(), logger.info()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""records,expected_count"", [
    ([{""id"": 1}], 1),
    ([{""id"": 1}, {""id"": 2}, {""id"": 3}], 3),
])
def test_sync_database(records, expected_count):
    mock_source = Mock()
    mock_source.fetch_all.return_value = records
    mock_target = Mock()
    mock_target.insert_batch.return_value = expected_count
    mock_logger = Mock()
    result = sync_database(mock_source, mock_target, mock_logger)
    assert result[""synced""] == expected_count
    mock_source.fetch_all.assert_called_once()
    mock_target.insert_batch.assert_called_once_with(records)
    assert mock_logger.info.called

def test_sync_database_connection_error():
    mock_source = Mock()
    mock_source.fetch_all.side_effect = ConnectionError(""Connection failed"")
    mock_target = Mock()
    mock_logger = Mock()
    with pytest.raises(ConnectionError):
        sync_database(mock_source, mock_target, mock_logger)

def test_sync_database_sync_failure():
    mock_source = Mock()
    mock_source.fetch_all.return_value = [{""id"": 1}]
    mock_target = Mock()
    mock_target.insert_batch.side_effect = RuntimeError(""Sync failed"")
    mock_logger = Mock()
    with pytest.raises(RuntimeError):
        sync_database(mock_source, mock_target, mock_logger)",,
"def compress_and_upload(data: bytes, compressor, uploader) -> str:
    """"""
    Compress data and upload to storage.
    
    Args:
        data: Raw bytes to compress and upload
        compressor: Compression function
        uploader: Upload function
    
    Returns:
        URL of uploaded file
    
    Raises:
        ValueError: If data is empty
        RuntimeError: If compression or upload fails
    
    # Dependencies: compressor(), uploader()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""data,compressed,url"", [
    (b""test data"", b""compressed"", ""https://storage.com/file1""),
    (b""large file content"", b""comp"", ""https://storage.com/file2""),
])
def test_compress_and_upload(data, compressed, url):
    mock_compressor = Mock(return_value=compressed)
    mock_uploader = Mock(return_value=url)
    result = compress_and_upload(data, mock_compressor, mock_uploader)
    assert result == url
    mock_compressor.assert_called_once_with(data)
    mock_uploader.assert_called_once_with(compressed)

def test_compress_and_upload_empty_data():
    mock_compressor = Mock()
    mock_uploader = Mock()
    with pytest.raises(ValueError):
        compress_and_upload(b"""", mock_compressor, mock_uploader)

def test_compress_and_upload_compression_failure():
    mock_compressor = Mock(side_effect=RuntimeError(""Compression failed""))
    mock_uploader = Mock()
    with pytest.raises(RuntimeError):
        compress_and_upload(b""data"", mock_compressor, mock_uploader)",,
"def monitor_service_health(service_url: str, checker, alerter) -> bool:
    """"""
    Monitor service health and send alerts.
    
    Args:
        service_url: URL of service to monitor
        checker: Health check function
        alerter: Alert sending function
    
    Returns:
        True if service is healthy
    
    Raises:
        ConnectionError: If unable to reach service
    
    # Dependencies: checker(), alerter()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""service_url,is_healthy"", [
    (""http://service1.com/health"", True),
    (""http://service2.com/health"", True),
])
def test_monitor_service_health_healthy(service_url, is_healthy):
    mock_checker = Mock(return_value=is_healthy)
    mock_alerter = Mock()
    result = monitor_service_health(service_url, mock_checker, mock_alerter)
    assert result == True
    mock_checker.assert_called_once_with(service_url)
    mock_alerter.assert_not_called()

def test_monitor_service_health_unhealthy():
    mock_checker = Mock(return_value=False)
    mock_alerter = Mock()
    result = monitor_service_health(""http://service.com/health"", mock_checker, mock_alerter)
    assert result == False
    mock_alerter.assert_called_once()

def test_monitor_service_health_connection_error():
    mock_checker = Mock(side_effect=ConnectionError(""Unreachable""))
    mock_alerter = Mock()
    with pytest.raises(ConnectionError):
        monitor_service_health(""http://service.com/health"", mock_checker, mock_alerter)",,
"def aggregate_metrics(metrics: list[dict], aggregator, storage) -> dict:
    """"""
    Aggregate metrics and store results.
    
    Args:
        metrics: List of metric dictionaries
        aggregator: Metric aggregation function
        storage: Storage service for results
    
    Returns:
        Aggregated metrics dictionary
    
    Raises:
        ValueError: If metrics list is empty
        RuntimeError: If aggregation or storage fails
    
    # Dependencies: aggregator(), storage.save()
    """"""","import pytest
from unittest.mock import Mock

@pytest.mark.parametrize(""metrics,aggregated"", [
    ([{""count"": 10}, {""count"": 20}], {""total"": 30}),
    ([{""value"": 5}], {""total"": 5}),
])
def test_aggregate_metrics(metrics, aggregated):
    mock_aggregator = Mock(return_value=aggregated)
    mock_storage = Mock()
    result = aggregate_metrics(metrics, mock_aggregator, mock_storage)
    assert result == aggregated
    mock_aggregator.assert_called_once_with(metrics)
    mock_storage.save.assert_called_once_with(aggregated)

def test_aggregate_metrics_empty_list():
    mock_aggregator = Mock()
    mock_storage = Mock()
    with pytest.raises(ValueError):
        aggregate_metrics([], mock_aggregator, mock_storage)

def test_aggregate_metrics_aggregation_failure():
    mock_aggregator = Mock(side_effect=RuntimeError(""Aggregation failed""))
    mock_storage = Mock()
    with pytest.raises(RuntimeError):
        aggregate_metrics([{""count"": 1}], mock_aggregator, mock_storage)",,