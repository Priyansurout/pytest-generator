context
"def process_payment(order_id: int, payment_gateway: Any) -> dict:\n    \"\"\"Process payment through gateway.\n    \n    Args:\n        order_id: Order to process\n        payment_gateway: Payment processor\n        \n    Returns:\n        Payment result dict\n        \n    Raises:\n        ValueError: If order_id invalid\n        \n    # Dependencies: payment_gateway.charge()\n    \"\"\"\n    pass"
"context
"async def fetch_user_data(user_id: str, http_client: Any) -> dict:\n    \"\"\"Fetch user from API.\n    \n    Args:\n        user_id: User identifier\n        http_client: Async HTTP client\n        \n    Returns:\n        User profile data\n        \n    Raises:\n        ConnectionError: If API unreachable\n        \n    # Dependencies: http_client.get()\n    \"\"\"\n    pass"
"context
"def calculate_statistics(values: List[float]) -> dict:\n    \"\"\"Calculate mean and std dev.\n    \n    Args:\n        values: List of numbers\n        \n    Returns:\n        Dict with mean and std keys\n        \n    Raises:\n        ValueError: If empty list\n    \"\"\"\n    pass"
"context
"class DataProcessor:\n    def validate_and_save(self, records: List[dict], db_conn: Any) -> int:\n        \"\"\"Validate records and save to database.\n        \n        Args:\n            records: Data to save\n            db_conn: Database connection\n            \n        Returns:\n            Number of records saved\n            \n        Raises:\n            TypeError: If invalid record format\n            \n        # Dependencies: db_conn.execute(), db_conn.commit()\n        \"\"\"\n        pass"
"context
"def send_email_notification(to: str, subject: str, body: str, smtp_client: Any) -> bool:\n    \"\"\"Send email via SMTP.\n    \n    Args:\n        to: Recipient address\n        subject: Email subject\n        body: Message content\n        smtp_client: SMTP connection\n        \n    Returns:\n        True if sent successfully\n        \n    Raises:\n        ConnectionError: If SMTP fails\n        \n    # Dependencies: smtp_client.sendmail()\n    \"\"\"\n    pass"
"context
"def merge_sorted_lists(list_a: List[int], list_b: List[int]) -> List[int]:\n    \"\"\"Merge two sorted lists.\n    \n    Args:\n        list_a: First sorted list\n        list_b: Second sorted list\n        \n    Returns:\n        Merged sorted list\n        \n    Raises:\n        TypeError: If inputs not lists\n    \"\"\"\n    pass"
"context
"def validate_user_input(data: dict, schema: dict) -> bool:\n    \"\"\"Validate data against schema.\n    \n    Args:\n        data: Input to validate\n        schema: Validation rules\n        \n    Returns:\n        True if valid\n        \n    Raises:\n        ValueError: If validation fails\n    \"\"\"\n    pass"
"context
"async def update_inventory(item_id: str, quantity: int, cache: Any, db: Any) -> bool:\n    \"\"\"Update inventory in cache and DB.\n    \n    Args:\n        item_id: Item SKU\n        quantity: New quantity\n        cache: Cache client\n        db: Database connection\n        \n    Returns:\n        True if updated\n        \n    Raises:\n        RuntimeError: If update fails\n        \n    # Dependencies: cache.set(), db.update()\n    \"\"\"\n    pass"
"context
"def calculate_discounted_price(price: float, category: str, discount_service: Any) -> float:\n    \"\"\"Apply discount based on category.\n    \n    Args:\n        price: Original price\n        category: Item category\n        discount_service: Service to get discount rates\n        \n    Returns:\n        Final price after discount\n        \n    Raises:\n        ValueError: If price negative\n        \n    # Dependencies: discount_service.get_rate()\n    \"\"\"\n    pass"
"context
"def parse_csv_file(filepath: str, delimiter: str = ',') -> List[dict]:\n    \"\"\"Parse CSV to list of dicts.\n    \n    Args:\n        filepath: Path to CSV file\n        delimiter: Field separator\n        \n    Returns:\n        List of row dicts\n        \n    Raises:\n        FileNotFoundError: If file missing\n    \"\"\"\n    pass"
"context
"def compute_aggregate_metrics(data: List[dict], metric_key: str, aggregator: Any) -> float:\n    \"\"\"Compute aggregated metric.\n    \n    Args:\n        data: Records to aggregate\n        metric_key: Field to aggregate\n        aggregator: Aggregation service\n        \n    Returns:\n        Aggregated value\n        \n    Raises:\n        KeyError: If metric_key missing\n        \n    # Dependencies: aggregator.compute()\n    \"\"\"\n    pass"
"context
"def authenticate_user(username: str, password: str, auth_service: Any) -> str:\n    \"\"\"Authenticate and return token.\n    \n    Args:\n        username: User login\n        password: User password\n        auth_service: Authentication provider\n        \n    Returns:\n        Auth token string\n        \n    Raises:\n        PermissionError: If auth fails\n        \n    # Dependencies: auth_service.verify()\n    \"\"\"\n    pass"
"context
"def format_currency(amount: float, currency: str, locale_service: Any) -> str:\n    \"\"\"Format amount as currency string.\n    \n    Args:\n        amount: Numeric amount\n        currency: Currency code\n        locale_service: Localization service\n        \n    Returns:\n        Formatted string\n        \n    # Dependencies: locale_service.format()\n    \"\"\"\n    pass"
"context
"def check_api_health(endpoint: str, timeout: float, http_client: Any) -> bool:\n    \"\"\"Check if API endpoint is healthy.\n    \n    Args:\n        endpoint: URL to check\n        timeout: Request timeout\n        http_client: HTTP client\n        \n    Returns:\n        True if healthy (200 OK)\n        \n    Raises:\n        TimeoutError: If request times out\n        \n    # Dependencies: http_client.get()\n    \"\"\"\n    pass"
"context
"def normalize_data_points(points: List[float], method: str = 'minmax') -> List[float]:\n    \"\"\"Normalize data using specified method.\n    \n    Args:\n        points: Raw data values\n        method: 'minmax' or 'zscore'\n        \n    Returns:\n        Normalized values\n        \n    Raises:\n        ValueError: If invalid method or empty input\n    \"\"\"\n    pass"
"context
"def sync_user_profile(user_id: int, source_api: Any, target_db: Any) -> dict:\n    \"\"\"Sync user from API to database.\n    \n    Args:\n        user_id: User to sync\n        source_api: Source API client\n        target_db: Target database\n        \n    Returns:\n        Synced user data\n        \n    Raises:\n        ConnectionError: If API or DB fails\n        \n    # Dependencies: source_api.fetch_user(), target_db.save()\n    \"\"\"\n    pass"
"context
"def calculate_shipping_cost(weight: float, destination: str, rate_calculator: Any) -> float:\n    \"\"\"Calculate shipping cost.\n    \n    Args:\n        weight: Package weight in kg\n        destination: Delivery location\n        rate_calculator: Rate lookup service\n        \n    Returns:\n        Shipping cost\n        \n    Raises:\n        ValueError: If weight negative\n        \n    # Dependencies: rate_calculator.get_rate()\n    \"\"\"\n    pass"
"context
"def validate_email_format(email: str) -> bool:\n    \"\"\"Check if email format is valid.\n    \n    Args:\n        email: Email address to validate\n        \n    Returns:\n        True if valid format\n        \n    Raises:\n        TypeError: If input not string\n    \"\"\"\n    pass"
"context
"def batch_insert_records(records: List[dict], table_name: str, db_connection: Any) -> int:\n    \"\"\"Insert multiple records into database.\n    \n    Args:\n        records: Records to insert\n        table_name: Target table\n        db_connection: Database connection\n        \n    Returns:\n        Number of records inserted\n        \n    Raises:\n        RuntimeError: If insertion fails\n        \n    # Dependencies: db_connection.executemany(), db_connection.commit()\n    \"\"\"\n    pass"
"context
"def fetch_weather_data(city: str, api_client: Any, cache: Any) -> dict:\n    \"\"\"Get weather data with caching.\n    \n    Args:\n        city: City name\n        api_client: Weather API client\n        cache: Cache store\n        \n    Returns:\n        Weather data dict\n        \n    Raises:\n        KeyError: If city not found\n        \n    # Dependencies: cache.get(), api_client.fetch(), cache.set()\n    \"\"\"\n    pass"
"context
"def retry_operation(operation: Callable, max_retries: int = 3) -> Any:\n    \"\"\"Retry operation on failure.\n    \n    Args:\n        operation: Callable to execute\n        max_retries: Maximum attempts\n        \n    Returns:\n        Operation result\n        \n    Raises:\n        RuntimeError: If all retries fail\n    \"\"\"\n    pass"
